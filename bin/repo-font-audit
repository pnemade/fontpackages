#!/bin/bash
# Quick and dirty script to audit font repartition in a yum package repository
#
# It is slow, it is ugly, and it requires a good network connection

# Function declarations

usage() {
/bin/cat >&2 << EOF_USAGE
Usage: $0 <id> <location>
<id>:       identifier of the package repository to check
<location>: location of the package repository to check

Examples:
$0 tmp file:///tmp/rpm
$0 rawhide http://example.com/mirrors/fedora.redhat.com/fedora/linux/development/x86_64/os/

EOF_USAGE
exit 1
}



# FIXME: only extracts info about the first typeface in a TTC file for now
parse_localized_fc_query() {
  field="$1"
  file="$2"
  fieldstring=$(awk -F ':' -v field="$field"  '$1 == "\t"field { print $2 ; exit }' "$file" \
               | sed 's="(s)="=g' | sed 's=" *"=|=g'| sed 's= *" *==g')"|"
  default=$(echo $fieldstring | awk -F "|" '{ print $1 }')
  if $(grep -q "^"$'\t'$field"lang:" "$file") ; then
    langstring=$(awk -F ':' -v field="$field" \
                '$1 == "\t"field"lang" { print $2 ; exit }' "$file" \
                | sed 's="(s)="=g' | sed 's=" *"=|=g'| sed 's= *" *==g')"|"
    # Try to find the English label
    while [ "$langstring" != "" -a \
            "$(echo $langstring | awk -F '|' '{ print $1 }')" != "en" ] ; do
      fieldstring=$(echo "$fieldstring" | sed 's+\([^|]*\)|\(.*\)+\2+g')
      langstring=$(echo "$langstring" | sed 's+\([^|]*\)|\(.*\)+\2+g')
    done
    # We could hide problems by reporting the first label regardless of its
    # language. But this is an audit script — we do not hide problems
    echo "$fieldstring" |  awk -F "|" '{ print $1 }'
    if [ "$fieldstring" == "" ] ; then  echo -ne "\b×" >&2 ; fi
  else
    echo $(echo $fieldstring | awk -F "|" '{ print $1 }')
  fi
}


pretty_indent() {
  fold -s -w $(($(tput cols) - 4)) \
  | while read line ; do echo "    $line" ; done
  echo ""
}

tally() {
t_datafile=$1

t_file=$(cat "$t_datafile" | wc -l)
t_file_size=$(awk -F '|' '{ sum += $14 } END { print sum }' "$t_datafile")
t_file_size=$((t_file_size/(1024*1024)))

t_rpm=$(awk -F '|' '{ print $2 "-" $3 "." $4 }' "$t_datafile" | sort | uniq | wc -l)
t_rpm_size=$(awk -F '|' '{ print $2 "-" $3 "." $4 "|" $5 }' "$t_datafile" | sort | uniq \
            |awk -F '|' '{ sum += $2 } END { print sum }')
t_rpm_size=$((t_rpm_size/(1024*1024)))

t_srpm=$(awk -F '|' '{ print $1 }' "$t_datafile" | sort | uniq | wc -l)

echo "$t_file|$t_rpm|$t_srpm|$t_file_size|$t_rpm_size"
}

summary() {
if [ $(cat "$1" | wc -l) -gt 0 ] ; then
  tally "$1" | awk -F '|' '{ print "⇒ " $1 " file(s) (" $4 " MiB) in " $2 \
        " package(s) (" $5 " MiB) generated from " $3 " source package(s)." }' \
        | pretty_indent
else
  echo "⇒  None!" | pretty_indent
fi
}

# $1 = summary file
# $2 = temporary data file
# $3 = test number
# $4 = test label
complete_csv_summary() {
  testcol=$(($3+3))
  awk -F '|' -v testcol="$testcol" -v testlabel="$4" \
      'FNR==1 {
       if ( testcol < NF )
              max = NF
            else
              max = testcol
        newline = ""
        for (i = 1 ; i <= max ; i++) {
           if ( i > 1 ) newline = newline "|"
           if ( i == testcol )
             { newline = newline testlabel }
           else
             { newline = newline $i }
         }
        print newline
       }' "$1" > tmp/tmp.ccs.header.csv
  awk -F '|' -v t_datafile="$2" -v testcol="$testcol" \
      'FILENAME==t_datafile { fail[$1"|"$2"|"$9] = 1 }
       FILENAME!=t_datafile && FNR>1 {
         if ( testcol < NF )
              max = NF
            else
              max = testcol
         line = $1 "|" $2 "|" $3
         newline = ""
         for (i = 1 ; i <= max ; i++) {
           if ( i > 1 ) newline = newline "|"
           if ( i == testcol )
             { newline = newline fail[line] }
           else
             { newline = newline $i }
         }
         print newline
         processed[line] = 1
       }
       END {
         for ( line in fail ) {
           if ( ! processed[line] ) {
             newline = line
             for (i = 4 ; i < testcol ; i++) {
               newline = newline "|"
             }
             newline = newline "|" fail[line]
             print newline
           }
         }
       }' "$2" "$1" | sort -t "|" > tmp/tmp.ccs.body.csv
  cat tmp/tmp.ccs.header.csv tmp/tmp.ccs.body.csv > "$1"
  rm tmp/tmp.ccs.header.csv tmp/tmp.ccs.body.csv
}

substats() {
ss_datafile="$1"

awk -F '|' '{ print $NF }' "$ss_datafile" | sort | uniq \
  | while read key ; do
    echo -n "$key|"
    awk -F '|' -v key="$key" '$NF==key' "$ss_datafile" > tmp/tmp.ss.csv
    tally tmp/tmp.ss.csv
    rm tmp/tmp.ss.csv
  done
}

stats() {
s_datafile="$1"

summary "$s_datafile"

if [ $(cat "$s_datafile" | wc -l) -gt 0 ] ; then
  (echo "Format|Files|rpm|srpm|Files (MiB)|rpm (MiB)"
  awk -F '|' '$12 != "" { print $0 "|" $12 }' "$s_datafile" > tmp/tmp.s.csv
  substats tmp/tmp.s.csv) | column -t -s '|' | pretty_indent

  (echo "Format|Files|rpm|srpm|Files (MiB)|rpm (MiB)"
  awk -F '|' '{ print $0 "|" $4 }' "$s_datafile" > tmp/tmp.s.csv
  substats tmp/tmp.s.csv)| column -t -s '|' | pretty_indent

  rm tmp/tmp.s.csv
fi
}

list-rpm() {

if [ $(cat "$1" | wc -l) -gt 0 ] ; then
  awk -F '|' '{ if ( $6 == "M" ) print "[" $2 "]" ; \
                            else print     $2     }' "$1" | sort | uniq \
    | awk -F '|' '{ list = list " " $1 } END { print list }' | pretty_indent
fi
}

canonalise_and_invert_string() {
  cais=""
  for token in $(echo "$@" | sed "s=[ \t_\.-]\+= =g" | sed "s=^ ==g" \
                           | sed "s= $==g") ; do
      cais="$token $cais"
  done
  echo " $cais"
}

wws_resolve () {
cais_name=$(canonalise_and_invert_string $1)
result="$cais_name"
patterns=""
for pattern in $2 ; do patterns="$pattern $patterns" ; done
for pattern in $patterns ; do
   pattern=$(canonalise_and_invert_string $pattern)
   tmp=$(echo "$cais_name" | sed "s=$pattern= =i")
   [ "$tmp" != "$cais_name" ] && result="$tmp"
done
result=$(canonalise_and_invert_string "$result" \
         | sed "s=^ ==" | sed "s= $==")
echo "$result"
}

# $1 csv with test results
test_score() {


if [ $(cat "$1" | wc -l) -gt 1 ] ; then
  (
    echo "SRPM|RPM|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17"
    awk -F '|' ' FNR>1 {
        id = $1 "|" $2
        fail[id] = 1
        if ( max < NF ) { max = NF }
        for (i = 4 ; i <= NF ; i++) {
          score[id"|"i] = score[id"|"i] + $i
        }
      }
      END {
        for ( id in fail ) {
          newline = id
          for (i = 4 ; i <= NF ; i++) {
            newline = newline "|" score[id"|"i]
          }
          print newline
        }
    }' "$1" | sort -t '|'
  ) | column -t -s '|'

 echo ""

 awk -F '|' 'FNR==1 {
   for (i = 4 ; i <= NF ; i++) {
     print "— test " i-3 ": " $i
   }
 }' "$1" | column -t -s ':'
else
  echo "⇒  None!"
fi

}

collect() {
echo "Searching for packages with font metadata…"
repoquery --repofrompath=$REPOID,$REPOURL --repoid=$REPOID \
          --qf "%{sourcerpm}|%{name}|%{epoch}:%{version}-%{release}|%{arch}|%{packagesize}" \
          --whatprovides "font(*)" --quiet \
          | sed 's=^\([^|]\+\?\)\-\([^-|]\+\?\)\-\([^-|]\+\?\)|=\1|=g' \
          | sort | uniq > "$FPL"

echo "Searching for packages that include files with common font extensions…"
repoquery --repofrompath=$REPOID,$REPOURL --repoid=$REPOID \
          --qf "%{sourcerpm}|%{name}|%{epoch}:%{version}-%{release}|%{arch}|%{packagesize}" \
          -f '*.ttf' -f '*.otf' -f '*.ttc' \
          -f '*.pfb' -f '*.pfa' -f '*.pcf.gz' --quiet \
          | sed 's=^\([^|]\+\?\)\-\([^-|]\+\?\)\-\([^-|]\+\?\)|=\1|=g' \
          | sort | uniq > "$PWFL"

if [ $(cat "$FPL" "$PWFL" | wc -l) -eq 0 ] ; then
  echo "Nothing to do!"
  exit
fi

echo "Inspecting packages:"
rm -f "$FFL"
cd "tmp"
cat "../$FPL" "../$PWFL" | awk -F '|' '{ print $2 "-" $3 "." $4 }' | sort | uniq \
  | while read rpm ; do
  echo -n " – $rpm"
  mkdir "$rpm"
  cd "$rpm"
  echo -n " ◔"
  rpm_loc=$(repoquery --repofrompath=$REPOID,$REPOURL --repoid=$REPOID --location "$rpm" 2>/dev/null)
  if $(echo "$rpm_loc" | grep -q -e "^file://") ; then
    rpm_file=$(echo "$rpm_loc" | sed "s=^file://=/=")
  else
    wget --quiet -O "$rpm.rpm" "$rpm_loc"
    rpm_file="$rpm.rpm"
  fi
  echo -ne "\b◑"
  rpmlint_score=$(rpmlint "$rpm_file" > "../rpmlint-$rpm.txt" 2>&1 ; echo $?)
  rpm2cpio "$rpm_file" > "$rpm.cpio"
  echo -ne "\b◕"
  cpio --quiet -it < "$rpm.cpio" > "$rpm.lst"
  nofont_score=$(cat "$rpm.lst" \
    | grep -v "^./usr/share/fonts" \
    | grep -v "^./usr/share/fontconfig/conf.avail/" \
    | grep -v "^./etc/fonts/conf.d/" \
    | grep -v "^./usr/share/doc/" \
    | grep -v "^./etc/X11/fontpath.d/" \
    | grep -viE '\.((ttf)|(ttc)|(otf)|(pfa)|(pfb)|(pcf)|(pcf\.gz))$' |wc -l)
  cat "$rpm.lst" \
    | grep -iE '\.((ttf)|(ttc)|(otf)|(pfa)|(pfb)|(pcf)|(pcf\.gz))$' \
    > "$rpm.fonts.lst"
  cpio -idm --quiet -E "$rpm.fonts.lst" < "$rpm.cpio"
  echo -ne "\b● "
  cat "$rpm.fonts.lst" | while read file; do
    unset target checksum type family style format
    type=$(file -bzh "$file")
    case $(echo "$type" | sed 's+ (\(.*\)++g' \
                             | sed 's+ `\(.*\)++g' \
                             | sed 's+,\(.*\)++g' \
                             | sed 's+\( \)*$++g' ) in
      "TrueType font data")
        echo -n "t"
        ;;
      "TrueType font collection data")
        echo -n "T"
        ;;
      "OpenType font data")
        echo -n "o"
        ;;
      "X11 Portable Compiled Font data")
        echo -n "b"
        ;;
      # PostScript files are a mess
      "PostScript Type 1 font text")
        echo -n "P"
        ;;
      "PostScript Type 1 font program data")
        echo -n "p"
        ;;
      "PostScript document text conforming DSC level 3.0")
        type="ignored"
        echo -n "-"
        ;;
      "PostScript document text"|"8086 relocatable")
        echo -n "x" >&2
        ;;
      "symbolic link to"|"broken symbolic link to")
        target=$(readlink -m "$file" | sed "s+^$PWD++g")
        if $(echo "$target" | grep -q "^/usr/share/fonts") ; then
          type="Link"
          echo -n "l"
        else
          type="ignored"
          echo -n "-"
        fi
        ;;
      *)
        echo -n "?"
        ;;
    esac
    if [ "$type" != "ignored" ] ; then
      size=$(du -b "$file" | awk '{ print $1 ; exit }')
      if [ ! -h "$file" ] ; then
        checksum=$(sha256sum "$file" | awk '{ print $1 ; exit }')
        if $(fc-query "$file" 2> /dev/null > "$file.desc") ; then
          family=$(parse_localized_fc_query family "$file.desc")
          style=$(parse_localized_fc_query style "$file.desc")
          format=$(parse_localized_fc_query fontformat "$file.desc")
        else
          echo -ne "\bX" >&2
        fi
      fi
      file=$(echo "$file" | sed "s+^./+/+g")
      echo "$rpm|$rpmlint_score|$nofont_score\
|$file|$family|$style|$format|$type|$size|$checksum|$target" >> "../../$FFL"
    fi
  done
  cd ..
  rm -fr "$rpm"
  echo " ♻"
done
cd ..
}

consolidate() {
echo "Consolidating data…"

rm -f "$FL"
cat "$PWFL" | while read rpmline; do
  grep -q "$rpmline" "$FPL" && metadata="M" || metadata=""
  rpm=$(echo "$rpmline" | awk -F '|' '{ print $2 "-" $3 "." $4 ; exit }')
  awk -F '|' -v rpm="$rpm" '$1 == rpm' "$FFL" \
  | while read rawfileline ; do
    echo "$rawfileline" | \
      awk -F "|" '{ for (i = 2; i < NF; i++) list = list $i "|" } END { print list $NF }' \
      | while read fileline ; do
      if [ "$(echo $fileline| awk -F '|' '{ print $7 }')" == "Link" ] ; then
        source="$(awk -F '|' -v target=""$(echo $fileline| awk -F '|' '{ print $10 }')"" \
                   '$4 == target { print $1 ; exit }' ""$FFL"" )"
      else source=""
      fi
     echo "$rpmline|$metadata|$fileline|$source" >> "$FL"
     done
  done
done


awk -F '|' '$15 != "" { print $1 "|" $2 "|" $9 "|" $15 }' "$FL" | sort | uniq \
  | while read sig ; do
    awk -F '|' -v sig="$sig" \
        '($1 "|" $2 "|" $9 "|" $15) == sig { print $0 ; exit }' "$FL"
  done > "$FLNM"
}

analyse() {

echo ""
echo "Problem report:"
echo ""

echo "SRPM|RPM|File" > "$TSUM"

# Arch check

echo "– font files in arch packages:"

awk -F '|' '($13 != "Link") && ($4 != "noarch")' "$FL" > tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
awk -F '|' '{ print $2 "." $4 "|" $6 }' tmp/tmp.csv | sort | uniq \
  | awk -F '|' '{ if ( $2 == "M" ) list=(list " [" $1 "]") ;
                              else list=(list " "  $1    ) } END \
                { print list }' | pretty_indent

complete_csv_summary "$TSUM" tmp/tmp.csv 1 "Arch package"
summary tmp/tmp.csv

# Install location check

echo "– font files installed outside /usr/share/fonts:"

awk -F '|' '($13 != "Link") && ($9 !~ /^\/usr\/share\/fonts\//)' "$FL" > tmp/tmp.csv

list-rpm tmp/tmp.csv
complete_csv_summary "$TSUM" tmp/tmp.csv 2 "Outside /usr/share/fonts"
summary tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
echo "☛ Font files need to be installed under the /usr/share/fonts root for \
fontconfig to expose them." | pretty_indent

# Mixed contents check

echo "— fonts in packages that contain non-font data:"

awk -F '|' '($13 != "Link") && ($8 != "0")' "$FL" > tmp/tmp.csv

list-rpm tmp/tmp.csv
complete_csv_summary "$TSUM" tmp/tmp.csv 3 "Mixed with non-font data"
summary tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
echo "☛ Every font should be installable as-is without pulling in other \
material." | pretty_indent

# Metadata check

echo "– fonts in packages that do not declare font metadata:"

awk -F '|' '($13 != "Link") && ($6 != "M")' "$FL" > tmp/tmp.csv

list-rpm tmp/tmp.csv
complete_csv_summary "$TSUM" tmp/tmp.csv 4 "Without rpm metadata"
summary tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
echo "☛ Automatic font installation relies on this metadata being present \
to work." | pretty_indent

# Naming checks

echo "– fonts in packages that do not use font package naming conventions:"

awk -F "|" '($13 != "Link") && \
            $2 !~ /^[0-9abcdefghijklmnopqrstuvwxyz\.-]*-fonts$/' "$FL" \
            > tmp/tmp.csv

list-rpm tmp/tmp.csv
complete_csv_summary "$TSUM" tmp/tmp.csv 5 "Bad rpm naming"
summary tmp/tmp.csv

echo "— fonts that declare face attributes in family names:"

rm -f tmp/tmp.csv
touch tmp/tmp.csv
awk -F "|" '{ print $10 }' "$FL" | sort | uniq \
  | while read family ; do
    echo -n "$family|"
    echo " $family " | sed "s=[ \t_\.-]\+= =g"
  done > tmp/tmp1.csv
for token in Book Normal Regular Upright ita ital italic cursive \
             kursiv inclined oblique backslanted backslant slanted \
             extra_compressed ext_compressed ultra_compressed \
             ultra_condensed ultra_cond UltraCondensed compressed \
             extra_condensed ext_condensed extra_cond ext_cond \
             ExtraCondensed narrow compact semi_condensed semi_cond \
             SemiCondensed wide semi_expanded semi_extended SemiExpanded \
             extra_expanded ext_expanded extra_extended ext_extended \
             ExtraExpanded ultra_expanded ultra_extended UltraExpanded \
             condensed cond expanded extended extra_thin ext_thin \
             ultra_thin Thin extra_light ext_light ultra_light ExtraLight \
             semi_bold demi_bold DemiBold extra_bold ext_bold ultra_bold \
             ExtraBold extra_black ext_black ultra_black ExtraBlack bold \
             light medium black heavy nord demi ultra ; do
  token=$(echo " $token " | sed 's+_+ +g')
  awk -F "|" -v IGNORECASE=1 -v token="$token" \
  '$2 ~ token { print $1 }' tmp/tmp1.csv
done | sort | uniq | while read family ; do
  awk -F "|" -v family="$family" '$10 == family' "$FL" >> tmp/tmp.csv
done

awk -F "|" '{ print $10 }' tmp/tmp.csv | sort | uniq \
  | while read family ; do
    rpmlist=$(awk -F "|" -v family="$family" '$10 == family \
      { if ( $6 == "M" ) print "[" $2 "]" ; \
                    else print     $2     }' tmp/tmp.csv \
      | sort | uniq | while read rpm ; do echo -n "$rpm " ; done)
    echo "$family|$rpmlist"
  done | column -t -s '|' | pretty_indent

complete_csv_summary "$TSUM" tmp/tmp.csv 6 "Bad family naming"
summary tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
echo -e "☛ To be properly processed by applications face qualifiers need to \
be declared in face names (there may be a few false positives here as some \
common face qualifiers can be used with a different meaning in family names; \
if that's not the case, please ask the font upstream to fix its naming)." \
| pretty_indent

echo -n "— fonts that declare non-WWS compliant faces:  "

#FIXME It would also be great to check if the naming is corrected by the
#      fontconfig files shipped in the package, but this requires fixes in
#      fc-scan (ability to process non-deployed fontconfig files)
rm -f tmp/tmp.csv
touch tmp/tmp.csv
awk -F "|" '{ print $11 }' "$FL" | sort | uniq \
  | while read face ; do
    echo -ne "\b○"
    rface=$(wws_resolve "$face" "Book Normal Regular Roman Upright")
    echo -ne "\b◔"
    rface=$(wws_resolve "$rface" "ita ital italic cursive kursiv inclined \
                                  oblique backslanted backslant slanted")
    echo -ne "\b◑"
    rface=$(wws_resolve "$rface" "extra_compressed ext_compressed \
                                  ultra_compressed ultra_condensed \
                                  ultra_cond UltraCondensed compressed \
                                  extra_condensed ext_condensed extra_cond \
                                  ext_cond ExtraCondensed narrow compact \
                                  semi_condensed semi_cond SemiCondensed \
                                  wide semi_expanded semi_extended \
                                  SemiExpanded extra_expanded ext_expanded \
                                  extra_extended ext_extended ExtraExpanded \
                                  ultra_expanded ultra_extended \
                                  UltraExpanded condensed cond expanded \
                                  extended")
    echo -ne "\b◕"
    rface=$(wws_resolve "$rface" "extra_thin ext_thin ultra_thin Thin \
                                  extra_light ext_light ultra_light \
                                  ExtraLight semi_bold demi_bold DemiBold \
                                  extra_bold ext_bold ultra_bold ExtraBold \
                                  extra_black ext_black ultra_black \
                                  ExtraBlack bold light medium black heavy \
                                  nord demi ultra")
    if [ "$rface" != "" ] ; then
      awk -F "|" -v face="$face" '$11 == face' "$FL" >> tmp/tmp.csv
      echo -ne "\bx "
    else echo -ne "\b●"
    fi
  done
echo ""

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
awk -F "|" '{ print $10 ", " $11 }' tmp/tmp.csv | sort | uniq \
  | while read fontface ; do
    awk -F "|" -v fontface="$fontface" '($10 ", " $11) == fontface \
      { if ( $6 == "M" ) print fontface "|" $9 "|[" $2 "]" ; \
                    else print fontface "|" $9 "|"  $2     }' tmp/tmp.csv \
      | sort | uniq
  done | column -t -s '|' | pretty_indent

complete_csv_summary "$TSUM" tmp/tmp.csv 7 "Bad face naming"
summary tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
echo -e "☛ This WWS-like test checks if font faces use the: \n\
“width weight slant” \n\
naming convention. \n\
http://blogs.msdn.com/text/attachment/2249036.ashx \n\
(Microsoft resolves over a combined “Family Face” string, since our \
applications use “Family” and “Face” separately this test considers “Face” \
alone. We also reject weight abbreviations and suffixes, if a font uses them \
check compliance manually.) \n\
If your font is listed here please ask its upstream to fix its naming, and in \
the meanwhile add a fontconfig rule to your package to hide the breakage (see \
the remapping template)." | pretty_indent

# Duplication checks

echo "– exact file duplication (ignoring multilib):"
echo "☛ Ignoring multilib to keep it short" | pretty_indent

awk -F '|' '{ print $15 }' "$FLNM" | sort | uniq -d \
  | while read checksum ; do
    awk -F '|' -v checksum="$checksum" '$15==checksum' "$FLNM"
done > tmp/tmp.csv

awk -F '|' '{ print $15 }' tmp/tmp.csv | uniq \
  | while read checksum ; do
    awk -F '|' -v checksum="$checksum" '$15==checksum \
        { if ( $6 == "M" ) print $9 "|[" $2 "." $4 "]" ;
          else             print $9 "|"  $2 "." $4  }' \
    tmp/tmp.csv | column -t -s '|' | pretty_indent
  done

complete_csv_summary "$TSUM" tmp/tmp.csv 8 "Duplicated file"
summary tmp/tmp.csv

echo "– font faces duplicated by different packages:"
echo "☛ Excluding multilib and PCF fonts (because they are pretty much \
hopeless)." | pretty_indent

rm -f tmp/tmp.csv
touch tmp/tmp.csv
awk -F '|' '($10 != "") && ($11 != "") && ($12 != "PCF") && ($12 != "Type 1") \
    { print $2 "-" $3 "." $4 "|" $10 "|" $11 }' "$FLNM" \
    | sort | uniq | awk -F '|' '{ print $2 "|" $3 }' \
    | sort | uniq -d | while read face ; do
    awk -F '|' -v face="$face" \
        '($12 != "PCF") && (($10 "|" $11)==face)' "$FLNM" > tmp/tmp1.csv
    packages=$(awk -F '|' '{ if ( $6 == "M" ) print "[" $2 "]" ; \
                             else print $2 }' tmp/tmp1.csv \
               | sort | uniq | while read rpm ; do echo -n "$rpm " ; done)
    count=$(awk -F '|' '{ print $2 "-" $3 "." $4 }' tmp/tmp1.csv \
            | sort | uniq | wc -l)
    cat tmp/tmp1.csv >> tmp/tmp.csv
    echo "$count|$face|$packages"
  done | sort -nr | column -t -s '|' | pretty_indent

complete_csv_summary "$TSUM" tmp/tmp.csv 9 "Duplicated face (ext)"
summary tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
echo "☛ Face duplication wastes resources \
infrastructure and user side. Very often an upstream that copied some fonts \
will forget to keep them up to date, and the duplication will result in the \
distribution of old buggy data. Even if some duplicate font files are a \
genuine fork with different features from the original, applications won't be \
able to select them reliably because of naming collisions. We should alway \
ship a single version of any font face in a dedicated font package, and use \
fontconfig or symlinks to share it accross packages." | pretty_indent

echo "– font faces duplicated within a package (ignoring legacy formats):"

awk -F '|' '($10 != "") && ($11 != "") && ($12 != "PCF") && ($12 != "Type 1") \
    { print $2 "-" $3 "." $4 "|" $10 "|" $11 }' "$FLNM" \
  | sort | uniq -d | while read sig ; do
    awk -F '|' -v sig="$sig" \
        '($12 != "PCF") && ($12 != "Type 1") && \
         (($2 "-" $3 "." $4 "|" $10 "|" $11 ) == sig)' \
         "$FLNM" ;
    done > tmp/tmp.csv

awk -F '|' '{ print $2 "|" $10 "|" $11 "|" $9 }' tmp/tmp.csv \
  | column -t -s '|' | pretty_indent

complete_csv_summary "$TSUM" tmp/tmp.csv 10 "Duplicated face (int)"
summary tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
echo "☛ Face duplication within a package is almost certainly a bug, except \
for special symbol font families." | pretty_indent

# Bad mixing checks

echo "— packages that mix several font families (ignoring legacy formats):"

awk -F '|' '($10 != "") && ($12 != "PCF") && ($12 != "Type 1")
    {
      rpm = $2 "-" $3 "." $4
      if ( ! family[rpm] ) { family[rpm] = $10 }
      else { if ( family[rpm] != $10 ) { mixed[rpm] = 1 } }
    }
    END {
      for ( rpm in mixed ) { print rpm }
    }' "$FL" | while read rpm ; do
      awk -F '|' -v rpm="$rpm" '(($2 "-" $3 "." $4) == rpm)' "$FL"
    done > tmp/tmp.csv

list-rpm tmp/tmp.csv
complete_csv_summary "$TSUM" tmp/tmp.csv 11 "Family mixing"
summary tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
echo "☛ Reliable font autoinstallation requires shipping only one font family \
per font package. This indicates problems in the packaging or the packaged \
font metadata." | pretty_indent

# Symlink-related checks

echo "– packages that symlink font files:"

awk -F '|' '$13=="Link"' "$FL" > tmp/tmp.csv

list-rpm tmp/tmp.csv
complete_csv_summary "$TSUM" tmp/tmp.csv 12 "Font linking"
summary tmp/tmp.csv

if [ $(cat tmp/tmp.csv | wc -l) -gt 0 ] ; then
echo "    5 most symlinked packages:"
awk -F '|' '$13=="Link" { print $17 "|" $2 "-" $3 "." $4 }' "$FL" | sort | uniq \
| awk -F '|' '{ print $1 }' | uniq -c | sort -nr | head -5 | column -t | pretty_indent

echo "☛ Symlinking font files is a way for non-font \
packages to comply with guidelines and avoid duplicating files, but it is \
also a symptom of missing or incomplete fontconfig support in the package. \
Please ask upstream to use fontconfig (possibly, via a higher-level library \
such as pangocairo)." | pretty_indent
fi

echo "– broken symlinks to font files:"

awk -F '|' '($13 == "Link") && ($17 == "")' "$FL" > tmp/tmp.csv
awk -F '|' '{ print $9 " → " $16 "|" $2 "-" $3 "." $4  }' tmp/tmp.csv \
  | column -t -s "|" | pretty_indent

complete_csv_summary "$TSUM" tmp/tmp.csv 13 "Broken symlink"
summary tmp/tmp.csv

echo "– packages with fonts rpmlint errors on:"

awk -F '|' '($13 != "Link") && ($7 != "0")' "$FL" > tmp/tmp.csv

list-rpm tmp/tmp.csv
complete_csv_summary "$TSUM" tmp/tmp.csv 14 "rpmlint"
summary tmp/tmp.csv


# Magic and other parsing checks

echo "– packages with font files not identified as such by libmagic:"

awk -F '|' '($13 !~ /font/) && ($13 !~ /Font/) && ($13 != "Link")' "$FL" > tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
awk -F '|' '{ print $2 "-" $3 "." $4 }' tmp/tmp.csv | uniq \
  | while read rpm ; do
    awk -F '|' -v rpm="$rpm" '($2 "-" $3 "." $4) == rpm \
        { sum+=1 ; srpm =$1 } END \
        { print sum "|" rpm "|(" srpm ")|" }' tmp/tmp.csv
  done | sort -nr | column -t -s '|' | pretty_indent

complete_csv_summary "$TSUM" tmp/tmp.csv 15 "libmagic problem"
summary tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
echo "☛ Either libmagic has a bug or the files are malformed and need to be \
fixed or dumped." | pretty_indent

echo "– packages with font files fc-query can not parse:"

awk -F '|' '($13 != "Link") && ($12 == "")' "$FL" > tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
awk -F '|' '{ print $2 "-" $3 "." $4 }' tmp/tmp.csv | uniq \
  | while read rpm ; do
    awk -F '|' -v rpm="$rpm" '($2 "-" $3 "." $4) == rpm \
        { sum+=1 ; srpm =$1 } END \
        { print sum "|" rpm "|(" srpm ")|" }' tmp/tmp.csv
  done | sort -nr | column -t -s '|' | pretty_indent

complete_csv_summary "$TSUM" tmp/tmp.csv 16 "fc-query problem"
summary tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
echo "☛ Either fontconfig has a bug or the files are malformed and need to be \
fixed or dumped." | pretty_indent

echo "– packages with localized metadata but no English variant:"

awk -F '|' '($12 != "") && (($10 == "") || ($11 == ""))' "$FL" > tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
awk -F '|' '{ print $9 "|" $2 "-" $3 "." $4 }' tmp/tmp.csv \
  | column -t -s '|' | pretty_indent

complete_csv_summary "$TSUM" tmp/tmp.csv 17 "No English metadata"
summary tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
echo "☛ The font files need to be fixed to declare metadata in English too." \
| pretty_indent

}

sum_up() {
echo ""
echo "Statistics:"
echo ""

echo "– packages that declare font metadata:"
echo ""

awk -F '|' '$6=="M"' "$FL" > tmp/tmp.csv
stats tmp/tmp.csv

echo "☛ File size is computed as extracted, while rpm is a compressed \
format." | pretty_indent
echo "☛ Mid-term, files in legacy PCF or Type1 formats need to be converted \
or removed." | pretty_indent

echo "– font files in other packages (we should not find any!)"
echo ""

awk -F '|' '($6 != "M") && ($13 != "Link")' "$FL" > tmp/tmp.csv
stats tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
echo "☛ Bad packaging may result in arched packages or mixed content." \
| pretty_indent

echo "– problem summary:"
echo ""

test_score "$TSUM" | pretty_indent

}

# End of function declarations

[ "$#" -lt "2" ] && usage

TIMESTAMP=$(date -u +%Y%m%dT%H%M%S)
ID=$1
REPOID="$1-rfa-$TIMESTAMP"
REPOURL=$2
ORIGDIR="$PWD"

FPL="font-packages.csv"
PWFL="packages-with-fonts.csv"
FFL="font-files.csv"
CSL="checksums.csv"
FL="consolidated-data.csv"
FLNM="consolidated-data-no-multilib.csv"
TSUM="test-summary.csv"
RES="repo-font-audit-$ID-$TIMESTAMP"
SRES="repo-font-audit-$ID-$TIMESTAMP-short"

TMPDIR=$(mktemp -d --tmpdir=/tmp $RES-XXXXXXXXXX)
cd $TMPDIR

mkdir tmp

collect
consolidate
analyse | tee report.txt
sum_up  | tee summary.txt

sed -i "s=.$(echo -ne '\b')==g" report.txt

cp "$FL" "tmp/$FL"
echo "SRPM|RPM|EVR|Arch|RPM size|RPM metadata|rpmlint score|foreign data|filename|family name|face name|format (fontconfig)|format (libmagic)|file size|checksum|symlink target|symlink provider" > "$FL"
cat "tmp/$FL" >> "$FL"

mkdir "$RES/"
cp "$FL" "$TSUM" tmp/rpmlint-*.txt summary.txt report.txt "$RES/"

mkdir "$SRES/"
cp "$TSUM" summary.txt report.txt "$SRES/"

for report in "$RES" "$SRES" ; do
  tar cf "$report.tar" "$report"
  xz -9  "$report.tar"
  mv "$report.tar.xz" "$ORIGDIR/"
done


echo "1. Complete extracted data: $ORIGDIR/$RES.tar.xz"
echo "2. Short summary: $ORIGDIR/$SRES.tar.xz"
echo ""
echo "Generated using the repo-font-audit command from"
echo "http://fedoraproject.org/wiki/fontpackages"
cd "$ORIGDIR"
rm -fr "$TMPDIR"
echo "♻"
