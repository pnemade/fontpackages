#!/bin/sh
# Quick and dirty script to audit font use in a yum package repository
#
# It is slow, it is ugly, and it requires a good network connection

# Function declarations

usage() {
cat >&2 << EOF_USAGE
Usage: $0 <id> <location>
<id>:       identifier of the package repository to check
<location>: location of the package repository to check

Examples:
$0 tmp file:///tmp/rpm
$0 rawhide http://example.com/mirrors/fedora.redhat.com/fedora/linux/development/x86_64/os/

EOF_USAGE
exit 1
}

DATADIR="$(dirname $0)/../private"

# Filenames with whitespace or & + makefile = !!!
bad_pattern="[[:space:]&\:]"

pretty_indent() {
  fold -s -w $(($(tput cols) - 2)) \
  | while read line ; do echo "  $line" ; done
}

# $1 = CSV file to evaluate
tally() {

awk -F "|" '
  {
    filesize   += $15
    filenumber += 1
    rpmsz[$3 "-" $4 "." $5] = $6
    srpms[$2] = 1
  }
  END {
    for (rpm in rpmsz) {
      rpmsize   += rpmsz[rpm]
      rpmnumber +=1
    }
    for (srpm in srpms) {
      srpmnumber +=1
    }
    rpmsize  = rpmsize  / (1024*1024)
    filesize = filesize / (1024*1024)
    print filenumber "|" rpmnumber "|" srpmnumber "|" filesize "|" rpmsize
  }' "$1"
}


summary() {
if [ $(cat "$1" | wc -l) -gt 0 ] ; then
  tally "$1" | awk -F '|' '{ print "⇒ " $1 " file(s) (" $4 " MiB) in " $2 \
        " package(s) (" $5 " MiB) generated from " $3 " source package(s)." }'\
        | pretty_indent
else
  echo "⇒  None!" | pretty_indent
fi
echo ""
}


# $1 = summary file
# $2 = temporary data file
# $3 = test id
complete_csv_summary() {
  awk -F '|' -v t_datafile="$2" -v testlabel="$3" \
      'FILENAME==t_datafile { fail[$1"|"$2"|"$3"|"$4"|"$5"|"$10] = 1 }
       FILENAME!=t_datafile && FNR==1 {
        max = NF + 1
        header = $1
        for (i = 2 ; i <= max ; i++) {
           header = header "|" $i
         }
        print header testlabel
       }
       FILENAME!=t_datafile && FNR>1 {
         line = $1 "|" $2 "|" $3 "|" $4 "|" $5 "|" $6
         newline = $1
         for (i = 2 ; i <= max ; i++) {
           newline = newline "|" $i
         }
         print newline fail[line]
         processed[line] = 1
       }
       END {
         for ( line in fail ) {
           if ( ! processed[line] ) {
             newline = line
             for (i = 7 ; i <= max ; i++) {
               newline = newline "|"
             }
             print newline fail[line]
           }
         }
       }' "$2" "$1" > tmp/tmp.ccs.csv
  awk 'FNR==1' tmp/tmp.ccs.csv > "$1"
  awk 'FNR>1'  tmp/tmp.ccs.csv | sort -f -t '|' >> "$1"
  rm tmp/tmp.ccs.csv
}


substats() {
ss_datafile="$1"

awk -F '|' '{ print $NF }' "$ss_datafile" | sort | uniq \
  | while read key ; do
    echo -n "$key|"
    awk -F '|' -v key="$key" '$NF==key' "$ss_datafile" > tmp/tmp.ss.csv
    tally tmp/tmp.ss.csv
    rm tmp/tmp.ss.csv
  done
}


# $1 = CSV file to sum_up
stats() {
s_datafile="$1"

summary "$s_datafile"

if [ $(cat "$s_datafile" | wc -l) -gt 0 ] ; then
  (echo "Format|Files|rpm|srpm|Files (MiB)|rpm (MiB)"
  awk -F '|' '$13 != "" { print $0 "|" $15 }' "$s_datafile" > tmp/tmp.s.csv
  substats tmp/tmp.s.csv) | column -t -s '|' | pretty_indent
  echo ""

  (echo "Arch|Files|rpm|srpm|Files (MiB)|rpm (MiB)"
  awk -F '|' '{ print $0 "|" $5 }' "$s_datafile" > tmp/tmp.s.csv
  substats tmp/tmp.s.csv)| column -t -s '|' | pretty_indent
  echo ""

  rm tmp/tmp.s.csv
fi
}


# $1 = CSV file to sum_up
list_rpm() {

[ $(cat "$1" | wc -l) -gt 0 ] && \
awk -F '|' '
  {
    rpm = $3
    if ( $7 == "M" ) { rpm = "[" rpm "]" }
    total[rpm] += 1
  }
  END {
    n = asorti(total, sorted)
    for ( i = 1 ; i <= n ; i++ ) {
      line = line sorted[i] "(" total[sorted[i]] "), "
    }
    sub(", $","",line)
    print line
  }' "$1" | pretty_indent

}

# Pipe CSV file to sum_up
# It is assumed to be of the form
# rpm | pattern to match | pattern to display
# patterns may include # as separators
enum_rpm() {
awk -F '|' '
  BEGIN { print "" }
  {
    rpm = $1
    key = $2
    pat = $3
    files[key] = files[key] pat "#" rpm "|"
  }
  END {
    for (key in files) {
      sub("\\|$", "", files[key])
      total = split(files[key], lines,"|")
      pb[total] = pb[total] key "|"
    }
    n = asorti(pb, sorted)
    for (i = n; i >= 1; i--) {
      total = sorted[i]
      sub("\\|$", "", pb[total])
      split(pb[total], keys,"|")
      nk = asort(keys, sortedkeys)
      for ( k = 1 ; k <= nk ; k++ ) {
        key = sortedkeys[k]
        print gensub("#", ", ", "g", key)
        split(files[key], lines, "|")
        nl = asort(lines, sortedlines)
        for ( l = 1 ; l <= nl ; l++ ) {
          print "  " gensub("#", "\t", "G", lines[l])
        }
        print ""
      }
    }
  }' | pretty_indent
}


# $1 test id
# $2 "title" of "help"
test_help() {

[ "$2" == "help" ] && echo -n "☛ "

case "$1" in
 "outside-usr-share-fonts")
    case "$2" in
      "title")
        echo "Error: fonts deployed outside /usr/share/fonts"
        ;;
      "help")
        cat << EOF
Packager task

The standard location for font files is under the /usr/share/fonts root
(default fontconfig setting). Please simplify the work of font utilities
and use it exclusively. It is always possible to symlink font files
somewhere else on the file-system if an application requires it.

If you fear exposing your font files in fontconfig will cause problems,
please work with the fontconfig maintainers to resolve them.
EOF
        ;;
    esac
    ;;
  "without-rpm-metadata")
    case "$2" in
      "title")
        echo "Error: fonts in packages that do not declare font metadata"
        ;;
      "help")
        cat << EOF
Packager task

Font-specific rpm metadata is required for automatic font installation to
work. If you apply our font packaging templates, it will be generated at
package creation time.
EOF
        ;;
    esac
    ;;
  "family-mixing")
    case "$2" in
      "title")
        echo "Error: packages that mix different font families"
        ;;
      "help")
        cat << EOF
Packager task

Reliable font auto-installation requires shipping only one font family per
font package.

(If you've remapped some font names at the fontconfig level your package
may appear here pending some fontconfig fixes upstream is aware of).
EOF
        ;;
    esac
    ;;
  "duplicated-file")
    case "$2" in
      "title")
        echo "Error: exact font duplication"
        ;;
      "help")
        cat << EOF
Packager task, eventual upstream task

Several packages duplicate font files with the same checksum. This
needlessly wastes resources infrastructure and user side  and makes font
maintenance problematic.

A repository should always include only one version of a font file.

This test can not discriminate between packages and identity the correct
owner of the font files. His maintainer will be blamed with others. If
you're not him it is therefore unfriendly not to fix this error as soon as
you can.

It is always possible to reuse a font file packaged separately by adding a
dependency on the other package providing it, and accessing the font
through fontconfig.

If an application can not use fontconfig today this is a serious bug that
should be reported to the application upstream. Please ask it to add
fontconfig support to their code (usually, via a higher-level library
such as pango-cairo). However it can workarounded by the packager with
symlinks (that will need maintenance).
EOF
        ;;
    esac
    ;;
  "duplicated-face-ext")
    case "$2" in
      "title")
        echo "Error: font faces duplicated by different packages"
        ;;
      "help")
        cat << EOF
Packager task, eventual upstream task

Several packages duplicate font files with the same face name. This
needlessly wastes resources infrastructure and user side and makes font
maintenance problematic:

1. Very often an upstream that copied some fonts will forget to keep them
up to date, and the duplication will result in the distribution of old
buggy data.

2. Shipping the same font in different formats is also problematic:
different font formats have different features, and are processed by
different font libraries. It is almost impossible to create a font in
multiple formats that will all behave the same. Users hate fonts that do
not behave consistently everywhere.

3. Most of our applications use fontconfig to access fonts, and fontconfig
uses font names to identify files. Naming collisions make font selection
unreliable. So even genuine forks with different features from the
original are a problem if not renamed.

A repository should always include only one version of a font face.

This test can not discriminate between packages and identity the correct
owner of the font face. His maintainer will be blamed with others. If
you're not him it is therefore unfriendly not to fix this error as soon as
you can.

It is always possible to reuse a font file packaged separately by adding a
dependency on the other package providing it, and accessing the font
through fontconfig.

If an application can not use fontconfig today this is a serious bug that
should be reported to the application upstream. Please ask it to add
fontconfig support to their code (usually, via a higher-level library
such as pango-cairo). However it can workarounded by the packager with
symlinks (that will need maintenance).

If an application can not use a modern font format and forces the
re-packaging in an older format of an exiting font this is an application
bug that should be reported to the application upstream. In that case
these is no good solution possible baring the fixing of the application.
EOF
        ;;
    esac
    ;;
  "fc-query")
    case "$2" in
      "title")
        echo "Error: fonts fc-query can not parse"
        ;;
      "help")
        cat << EOF
Upstream task

fc-query could not parse some font files in the package. The files may be
malformed and in need of fixing, or fc-query has a bug.

Any font file rejected by fc-query will be useless in fontconfig and most
applications. If it can not be fixed drop it

Please relay the problem to the appropriate upstream to get it fixed.
EOF
        ;;
    esac
    ;;
  "libmagic")
    case "$2" in
      "title")
        echo "Error: fonts not identified as such by libmagic"
        ;;
      "help")
        cat << EOF
Upstream task

libmagic could not identify some files with font-like extensions in the
package. The files may be malformed and in need of fixing, or they use a
font extension when they should not, or libmagic has a bug.

Please relay the problem to the appropriate upstream to get it fixed.
EOF
        ;;
    esac
    ;;
  "broken-symlink")
    case "$2" in
      "title")
        echo "Error: broken symlinks to font files"
        ;;
      "help")
        cat << EOF
Packager and upstream task

The symlinked font file has moved, been renamed, or the symlink was never
properly set up. You need to change the symlink.

Symlinking requires maintenance and is only necessary when an application
lacks fontconfig support. If an application can not use fontconfig today
this is a serious bug that should be reported to the application upstream.
Please ask it to add fontconfig support to their code (usually, via a
higher-level library such as pango-cairo).
EOF
        ;;
    esac
    ;;
  "rpmlint")
    case "$2" in
      "title")
        echo "Error: rpmlint"
        ;;
      "help")
        cat << EOF
Packager task

Check rpmlint output to fix the listed packages (using the -i flag if you
don't understand rpmlint messages).
EOF
        ;;
    esac
    ;;
  "mixed-with-non-font-data")
    case "$2" in
      "title")
        echo "Error: fonts in packages that contain non-font data"
        ;;
      "help")
        cat << EOF
Packager task

Please do not mix font files with non-font data in packages. Fonts are
usually useful outside of the package that deploys them and should be
installable without pulling in other material.
EOF
        ;;
    esac
    ;;
  "arch-package")
    case "$2" in
      "title")
        echo "Error: fonts in arch packages"
        ;;
      "help")
        cat << EOF
Packager task

Fonts are not arch-specific; please make sure they are deployed in noarch
packages.
EOF
        ;;
    esac
    ;;
  "bad-rpm-naming")
    case "$2" in
      "title")
        echo "Warning: fonts in packages that do not respect font naming conventions"
        ;;
      "help")
        cat << EOF
Packager task

Please respect font package naming conventions and provide consistent
packages to users. Some scripts may depend on strict package naming.
EOF
        ;;
    esac
    ;;
  "bad-naming")
    case "$2" in
      "title")
        echo "Warning: bad font naming"
        ;;
      "help")
        cat << EOF
Font upstream task, with packager workarounds

The font naming declared by one or more files in the package is not a
canonical WWS¹ naming or has some other naming problem. As noted by Adobe²
the W3C CSS font family model used in WPF/WWS is less than ideal, but it is
a standard and applications expect it.

This script attempted to apply some heuristics to fix this naming, and
computed different values than those in the font files.

That means some of those files are using non-standard, fuzzy,
self-conflicting, confusing names. A correct naming:
1. only includes “Width”, “Weight”, “Slant” qualifiers in its style name;
2. does not declare more than one of each;
3. declares them using the canonical keywords defined in the WWS paper;
4. declares them in “Width”, “Weight”, “Slant” order;
3. uses spaces to separate them;
4. does not use “Width”, “Weight”, “Slant” qualifiers in its family name;
5. does not use symbols such as & that cause problems in SGML/XML/HTML
   contexts. 

The canonical naming computed by this script was printed at test time.
Please note that it is only correct in a formal sense: no attempt was made
to check that the computed naming corresponds to actual font
characteristics. It still needs human review (when the computed naming is
way off however that usually indicates the original naming is particularly
bad and confusing).

Because the aim of this test is to help improve overall font naming it will
not accept some user-unfriendly naming exceptions Microsoft handles in its
WPF heuristic. Also, the naming parsing used in this test is more aggressive
than the one Microsoft uses, so it will manage to “fix” some names WPF can
not, at the expense of a few false positives³.

The average application is not as smart as this script and will not attempt
to “fix” font naming in any way. Therefore, even if this script computed a
correct naming, you should not rely on applications doing the same. Please
ask the font usptream to fix the naming directly in the font file(s).

Packager workaround: patch the file (if it is available in .sfd format),
or add a fontconfig rule to your package to hide the problem⁴.

¹ http://blogs.msdn.com/text/attachment/2249036.ashx
  http://blogs.adobe.com/typblography/typotechnica2007/Font%20names.pdf
² http://blogs.adobe.com/typblography/atypi2006/CSS%20&%20OT%2015.pdf
³ For example the family name may include some words that look like a
  “Width”, “Weight”, “Slant” attribute, but that are used in a different
  sense. This script is not a natural language parser and can not detect
  those cases reliably
⁴ cf the “fontpackages” remapping template; unfortunately this workaround
  won't fix problems for non-fontconfig applications, or when
  interoperating with other systems.
EOF
        ;;
    esac
    ;;
  "core-fonts")
    case "$2" in
      "title")
        echo "Warning: core fonts use"
        ;;
      "help")
        cat << EOF
Upstream task

This package accesses fonts through the X11 Core protocol.

Numerous long-standing problems with this mode of access, and a design
that could not scale to modern font needs lead the (then XFree86) team to
deprecate it in favour of fontconfig (née xft). Adoption was quick and by
2003 it was clear fontconfig was the new standard¹. Nowadays fontconfig is
widely used², including on non Linux/Unix platforms.

While X11 Core access has been kept on life-support this font system is
not actively maintained today. The font library it depends on is slowly
shrinking, as it was created in a period of different legal and technical
requirements², and there is no one to update the font files when a problem
is found³. Therefore, projects are advised to migrate before the situation
reaches a critical stage.

Fontconfig has been our default font system for a long time, and accessing
fonts by other means will cause behaviour inconsistencies and many other
problems (since fontconfig can be used to change the behaviour of a font).

If an application can not use fontconfig today this is a serious bug that
should be reported to the application upstream. Please ask it to add
fontconfig support to their code (usually, via a higher-level library
such as pango-cairo).


¹ http://xfree86.org/pipermail/forum/2003-March/000799.html
² Screen technology changed, encoding standard (Unicode) changed, legal
reviews became more comprehensive, etc.
³ Leaving culling the only solution.
EOF
        ;;
    esac
    ;;
  "font-linking")
    case "$2" in
      "title")
        echo "Warning: font linking"
        ;;
      "help")
        cat << EOF
Upstream task

Symlinking is a way for non-font packages to avoid duplicating font files,
but it is also a symptom of missing or incomplete fontconfig support.

Fontconfig has been our default font system for a long time, and accessing
fonts by other means will cause behaviour inconsistencies and many other
problems (since fontconfig can be used to change the behaviour of a font).

If an application can not use fontconfig today this is a serious bug that
should be reported to the application upstream. Please ask it to add
fontconfig support to their code (usually, via a higher-level library
such as pango-cairo).
EOF
        ;;
    esac
    ;;
  "duplicated-face-int")
    case "$2" in
      "title")
        echo "Warning: font faces duplicated within a package"
        ;;
      "help")
        cat << EOF
Packager or upstream task

Face duplication within a package is almost certainly a bug (usually,
mis-naming in one of the font files), except for special symbol font
families.

1. Fonts that were split because of the limitations of legacy font formats
(PCF, Type 1…) should be converted to modern OpenType (TT, CFF or bitmap)
containers.

2. Shipping the same font in different formats is problematic: different
font formats have different features, and are processed by different font
libraries. It is almost impossible to create a font in multiple formats
that will all behave the same. Users hate fonts that do not behave
consistently everywhere.

3. Most of our applications use fontconfig to access fonts, and fontconfig
uses font names to identify files. Naming collisions make font selection
unreliable.

If an application can not use a modern font format and forces the
re-packaging in an older format of an exiting font this is an application
bug that should be reported to the application upstream. In that case
these is no good solution possible baring the fixing of the application.
EOF
        ;;
    esac
    ;;
  "fontlint")
    case "$2" in
      "title")
        echo "Warning: fonts that do not pass fontlint sanity checks"
        ;;
      "help")
        cat << EOF
Font upstream task

Fontforge's fontlint¹ test suite found problems in some files included in
the package. Those problems may not be obvious and only manifest as
strange behaviour in specific applications (making them hard to debug).
For that reason it is recommanded to report those problems upstream and
get them fixed, even if the font file seems to work fine most of the time.

You can ask help about specific fontlint errors on:
https://lists.sourceforge.net/lists/listinfo/fontforge-users

Please relay the problem report to the font upstream.

¹ http://fontforge.sourceforge.net/fontlint.html
EOF
        ;;
    esac
    ;;
  "no-english-metadata")
    case "$2" in
      "title")
        echo "Warning: fonts with localized metadata but no English variant"
        ;;
      "help")
        cat << EOF
Font upstream task

Some font files in the package declare localized metadata, but do not
include an English variant. They need to be fixed to also declare metadata
in English, so it can be used in technical declarations such as CSS rules.
(Sometimes font do include English metadata, but under another language
label. There is no way for applications or for this test to guess some
metadata is mislabeled).

Please relay the problem report to the font upstream.
EOF
        ;;
    esac
    ;;
  "partial-scripts")
    case "$2" in
      "title")
        echo "Suggestion: fonts with partial script coverage"
        ;;
      "help")
        cat << EOF
Font upstream task

Some font files included in the package are missing a few glyphs to be
accepted by fontconfig as covering one or several scripts. Therefore they
could be made useful to more people with only a little effort.

Many scripts differ by only a few glyphs and it is unfortunately common
for font authors not to notice they stopped just short of full support for
some of them.

To check a font file script coverage, run:
  $ FC_DEBUG=256 fc-query font-file
and look for lines like:
  script-id¹(number) { list-of-unicode-codepoints }

For example
  “mi(2) { 1e34 1e35 }”
means fontconfig will accept the tested file for Maori if codepoints 1e34
and 1e35 are added.

fontconfig is used by a lot of applications on many systems so ignoring
its opinion on a font is a mistake.

Please relay the incomplete coverage report to the font upstream.

P.S.
Of course fontconfig is not perfect either so it may require a glyph for a
script when it should not. In that case, please report the problem to
fontconfig upstream:
https://bugs.freedesktop.org/enter_bug.cgi?product=fontconfig
against the “orth” component.

¹ http://www.loc.gov/standards/iso639-2/php/code_list.php
² https://bugs.freedesktop.org/enter_bug.cgi?product=fontconfig
EOF
        ;;
    esac
    ;;
  "partial-blocks")
    case "$2" in
      "title")
        echo "Suggestion: fonts with partial unicode block coverage"
        ;;
      "help")
        cat << EOF
Font upstream task

Some font files included in the package are missing only a few glyphs to
fully cover an Unicode block. Therefore they could be made useful to more
people with only a little effort.

The Unicode consortium revises its tables regularly. A font may need to be
extended to maintain full coverage of a block when a new Unicode standard
revision is published¹.

To check the unicode coverage of a font, run the ttfcoverage command. (It
only works for modern .otf or .ttf fonts).

Please relay the incomplete coverage report to the font upstream.

¹ http://www.unicode.org/charts/
EOF
        ;;
    esac
    ;;
 *)
    echo "Unknown test."
    ;;
esac

[ "$2" == "help" ] && echo ""
}


# $1 = this test id
# $2 = csv file with the results of this test
# $3 = csv file that consolidates the results of all tests
test_wrapup() {

complete_csv_summary "$3" "$2" "$1"
summary "$2"

}


# $1 = csv file with test results
test_score() {
if [ $(cat "$1" | wc -l) -gt 1 ] ; then
  awk -F '|' '
    BEGIN {
      lh=7
      headerline = "P#"
    }
    FNR==1 {
      max = NF
    }
    FNR>1 {
      id = ""
      for (i = 1 ; i < (lh-1) ; i++) {
        if ($i != "") id = id $i "|"
        else          id = id   " |"
      }
      sub("\\|$","",id)
      fail[id] = 1
      for (i = lh ; i <= max ; i++) {
        score[id"|"i] = score[id"|"i] + $i
        totalscore[i] = totalscore[i] + $i
      }
    }
    END {
      for (i = lh ; i <= max ; i++) {
          if ( totalscore[i] ) { headerline  = headerline "|" "t" i+1-lh }
        }
      print headerline
      n = asorti(fail)
      for (l = 1; l <= n; l++) {
        newline = l
        for (c = lh ; c <= max ; c++) {
          if ( totalscore[c] ) {
            if ( score[fail[l]"|"c] )
              { newline = newline "|" score[fail[l]"|"c] }
            else
              { newline = newline "|‧" }
          }
        }
        print newline
      }
      totalline = "Total"
      for (i = lh ; i <= max ; i++) {
        if ( totalscore[i] ) { totalline = totalline "|"  totalscore[i] }
      }
      print totalline
    }' "$1" | column -t -s '|'

  echo ""

  awk -F '|' '
    BEGIN { lh=7 }
    FNR>1 {
      id = ""
      for (i = 1 ; i < (lh-1) ; i++) {
        if ($i != "") id = id $i "|"
        else          id = id   " |"
      }
      sub("\\|$","",id)
      fail[id] = 1
    }
    END {
      print "P#|Maintainer|SRPM|RPM|EVR|Arch"
      n = asorti(fail)
      for (l = 1; l <= n; l++) {
      print l "|" fail[l]
      }
    }' "$1" | column -t -s '|'

  echo ""
  echo "Test explanation:"
  echo ""

  awk -F '|' '
    BEGIN { lh = 7 }
    FNR==1 {
      max = NF
      for (i = lh ; i <= max ; i++) {
        legend[i] = i+1-lh "|" $i }
      }
    FNR>1 {
      for (i = lh ; i <= max ; i++) {
        totalscore[i] = totalscore[i] + $i
      }
    }
    END {
      for (i = lh ; i <= max ; i++) {
        if ( totalscore[i] ) { print legend[i] }
      }
    }' "$1" | while read line ; do
      testnumber=$(echo $line | awk -F '|' '{ print "t"$1 }')
      testid=$(echo $line | awk -F '|' '{ print $2 }')
      echo -n "$testnumber. "
      test_help $testid title
      echo ""
      ( test_help $testid help ) | pretty_indent
    done

else
  echo "⇒  None!"
fi

}


collect() {
echo "Looking for packages:"
echo "— with font metadata…"
repoquery --repofrompath=$REPOID,$REPOURL --repoid=$REPOID \
          --qf "%{sourcerpm}|%{name}|%{epoch}:%{version}-%{release}|%{arch}|%{packagesize}|M" \
          --whatprovides "font(*)" --quiet \
          | sort | uniq \
          | sed 's=^\([^|]\+\?\)\-\([^-|]\+\?\)\-\([^-|]\+\?\)|=\1|=g' \
          > "$FPL"

echo "— that include files with common font extensions…"
repoquery --repofrompath=$REPOID,$REPOURL --repoid=$REPOID \
          --qf "%{sourcerpm}|%{name}|%{epoch}:%{version}-%{release}|%{arch}|%{packagesize}|E" \
          -f '*.ttf' -f '*.otf' -f '*.ttc' \
          -f '*.pfb' -f '*.pfa' \
          -f '*.pcf.gz' -f '*.pcf' -f '*.bdf' --quiet \
          | sort | uniq \
          | sed 's=^\([^|]\+\?\)\-\([^-|]\+\?\)\-\([^-|]\+\?\)|=\1|=g' \
          > "$PWFL"

echo "— that use the core X11 protocol…"
repoquery --repofrompath=$REPOID,$REPOURL --repoid=$REPOID \
          --qf "%{sourcerpm}|%{name}|%{epoch}:%{version}-%{release}|%{arch}|%{packagesize}|X" \
          --whatrequires 'libX11.so*' \
          | sort | uniq \
          | sed 's=^\([^|]\+\?\)\-\([^-|]\+\?\)\-\([^-|]\+\?\)|=\1|=g' \
          > "$XPL"

if [ $(cat "$FPL" "$PWFL" "$XPL" | wc -l) -eq 0 ] ; then
  echo "Nothing to do!"
  exit
fi

cat "$FPL" "$PWFL" "$XPL" \
  | awk -F '|' '
      { tag[$1 "|" $2 "|" $3 "|" $4 "|" $5] = tag[$1 "|" $2 "|" $3 "|" $4 "|" $5] $6 "," }
      END {
        n =  asorti(tag,rpm)
        for (l = 1; l <= n; l++) {
          sub(",$", "", tag[rpm[l]])
          print rpm[l] "|" tag[rpm[l]]
        }
      }' > "tmp/$FL.1"

echo ""
echo "Inspecting packages:"
cd "tmp"
rm -f "$FL.2"

cat "$FL.1" | while read line ; do
  rpm=$(echo "$line" | awk -F '|' '{ print $2 "-" $3 "." $4 }')
  rpmline=$(echo "$line" | awk -F '|' '{ print $1 "|" $2 "|" $3 "|" $4 "|" $5 }')
  rpmd=$(echo "$rpm" | sed "s+$bad_pattern+_+g")
  echo "$line" | cut -d "|" -f 6 | grep -q "M" && metadata="M" || metadata=""
  echo -n "– $rpm "
  mkdir "$rpmd"
  cd "$rpmd"
  echo -n " ◔"
  rpm_loc=$(repoquery --repofrompath=$REPOID,$REPOURL --repoid=$REPOID --location "$rpm" 2>/dev/null)
  if $(echo "$rpm_loc" | grep -q -e "^file://") ; then
    ln -s $(echo "$rpm_loc" | sed "s=^file://=/=") .
  else
    wget --quiet "$rpm_loc"
  fi
  echo -ne "\b◑"
  rpm2cpio *.rpm > "$rpm.cpio"
  echo -ne "\b◕"
  cat "$rpm.cpio" | cpio --quiet -it > "$rpm.lst"
  nofont_score=$(cat "$rpm.lst" | sed 's=^\./=/=g' \
    | grep -viE -e "^/usr/share/fonts" \
                -e "^/usr/share/fontconfig/conf.avail/" \
                -e "^/etc/fonts/conf.d/" \
                -e "^/usr/share/doc/" \
                -e "^/etc/X11/fontpath.d/" \
                -e '\.((ttf)|(ttc)|(otf)|(pfa)|(pfb)|(bdf)|(pcf)|(pcf\.gz))$' \
    | wc -l)
  echo "$rpmline|$metadata|$nofont_score" > rpm-info.txt
  if $(echo $line | cut -d "|" -f 6 | grep -q "E") ; then
    cat "$rpm.lst" \
      | grep -iE '\.((ttf)|(ttc)|(otf)|(pfa)|(pfb)|(bdf)|(pcf)|(pcf\.gz))$' \
      | sort > "$rpm.fonts.lst"
  fi
  if $(echo $line | cut -d "|" -f 6 | grep -q "X") ; then
    cat "$rpm.lst" \
      | grep -i  -e "^./sbin/" \
                 -e "^./usr/sbin/" \
                 -e "^./usr/kerberos/sbin" \
                 -e "^./bin/" \
                 -e "^./usr/bin/" \
                 -e "^./usr/kerberos/bin/" \
                 -e "^./lib.*/" \
                 -e "^./usr/lib.*/" \
                 -e "^./opt/" \
                 -e "^./usr/X11R6/" \
                 -e "^./usr/games/" \
                 -e "^./usr/local/" \
      | grep -vi -e "^./usr/bin/dmxwininfo" \
                 -e "^./usr/bin/Xdmx" \
                 -e "^./usr/bin/xfontsel" \
                 -e "^./usr/bin/xlsfonts" \
                 -e "^./usr/bin/Xnest" \
                 -e "^./usr/bin/xprop" \
                 -e "^./usr/bin/xsetroot" \
                 -e "^./usr/bin/xwininfo" \
                 -e "^./usr/bin/x11vnc" \
                 -e "^./usr/bin/x2vnc" \
                 -e "^./usr/lib.*/libXcursor.so" \
      | sort > "$rpm.bin.lst"
  fi
  touch "$rpm.fonts.lst" "$rpm.bin.lst"
  cat "$rpm.fonts.lst" "$rpm.bin.lst"  | sort | uniq > "$rpm.files.lst"
  mkdir src
  cd src
  cpio -idm --quiet -E "../$rpm.files.lst" < "../$rpm.cpio"
  cd ..
  rm "$rpm.cpio"
  echo -ne "\b● "
  sed 's=^\./==g' "$rpm.fonts.lst" \
    | while read file; do
    unset target
    type=$(file -bzh "src/$file")
    case $(echo "$type" | sed 's+ (\(.*\)++g' \
                             | sed 's+ `\(.*\)++g' \
                             | sed 's+,\(.*\)++g' \
                             | sed 's+\( \)*$++g' ) in
      "TrueType font data")
        echo -n "t"
        ;;
      "TrueType font collection data")
        echo -n "T"
        ;;
      "OpenType font data")
        echo -n "o"
        ;;
      "X11 Portable Compiled Font data")
        echo -n "b"
        ;;
      "X11 BDF font text")
        echo -n "B"
        ;;
      # PostScript files are a mess
      "PostScript Type 1 font text")
        echo -n "P"
        ;;
      "PostScript Type 1 font program data")
        echo -n "p"
        ;;
      "PostScript document text conforming DSC level 3.0")
        type="ignored"
        echo -n "-"
        ;;
      "PostScript document text"|"8086 relocatable")
        echo -n "!" >&2
        ;;
      "symbolic link to"|"broken symbolic link to")
        target=$(readlink -m "src/$file" | sed "s+^$PWD/src++g")
        if $(echo "$target" | grep -q "^/usr/share/fonts") ; then
          type="Link"
          echo -n "l"
        else
          type="ignored"
          echo -n "-"
        fi
        ;;
      *)
        echo -n "?"
        ;;
    esac
    if [ "$type" != "ignored" -a ! -h "src/$file" ] ; then
       mkdir -p $(dirname "tmp/$file")
       echo "/$file|$type" > "tmp/$file.rfo.fonts.info"
       if [ "$type" != "TrueType font data" -a \
            "$type" != "OpenType font data" ] ; then
         touch "tmp/$file.rfo.unicover"
       fi
    fi
    if [ "$type" = "Link" ] ; then
      echo "/$file|$target" >> font-links.txt
    fi
  done

  sed 's=^\./==g' "$rpm.bin.lst" \
    | while read file ; do
    type=$(file -bzh "src/$file")
    if $(echo "$type" | grep -q -e '^ELF ' -e ' ELF ') ; then
      echo -n "‧"
      mkdir -p $(dirname "tmp/$file")
      echo "/$file|$type" > "tmp/$file.rfo.core-fonts.info"
    fi
  done

  echo ""
  cd ..
done

echo ""
echo "Analysing files…"

find . -type d | grep "$bad_pattern" \
  | while read dir ; do
      mkdir -p $(echo "$dir" | sed "s+$bad_pattern+_+g")
    done

find . -type f | grep "$bad_pattern" \
  | while read file ; do
      mv "$file" $(echo "$file"| sed "s+$bad_pattern+_+g")
    done

# There must be a cleaner way to do this
parallelism=$(($(cat /proc/cpuinfo | grep processor | wc -l)+1))
make -s -r -j $parallelism -f "$DATADIR/repo-font-audit.mk"

find .  -name "*\.rfo\.fonts" \
     -o -name "*\.rfo\.core-fonts" \
     -o -name processed-font-links.txt \
  | while read datafile ; do
      cat "$datafile" >> "$FL.2"
    done

mkdir ../data
for rpmlint in */rpmlint.txt ; do
  mkdir "../data/$(dirname $rpmlint)"
  mv "$rpmlint" "../data/$rpmlint"
done

for ext in fontlint unicover fc-query ; do
  find . -name "*\.rfo\.$ext" \
     | while read file ; do
          dest=$(echo "$file" \
            | sed "s+./\([^/]*\)/tmp/\(.*\).rfo.$ext+\1|\2.$ext.txt+" \
            | sed 's+/+_+g' | sed 's+|+/+g')
          [ -s "$file" ] && mv "$file" "../data/$dest"
       done
done

rm -fr "*/"
echo " ♻"
cd ..
}


consolidate() {
echo ""
echo "Consolidating data…"

echo "Maintainer|SRPM|RPM|EVR|Arch|RPM size|RPM metadata|foreign data|\
rpmlint score|filename|family name|face name|fixed family name|\
fixed face name|format (fontconfig)|format (libmagic)|file size|checksum|\
partial scripts|partial blocks|fontlint|symlink target|symlink provider|\
core fonts use" > "$FL"

if  [ -s "tmp/$FL.2" -a -r "tmp/$FL.2" ] ; then

  # FIXME: make this distro-agnostic
  cut -d "|" -f 1 "tmp/$FL.2" | sort | uniq \
    | /usr/bin/fedoradev-pkgowners 2>/dev/null \
    | sed 's+ +|+g' \
    | awk -F "|" -v file="tmp/$FL.2" '
        { owner[$2]=$1 }
        END {
          while ((getline < file) > 0) {
            print owner[$1] "|" $0
          }
        }' | sort -df -t "|" -k 1 -k 2 -k 3 > "tmp/$FL.3"

  awk -F "|" '
    ($16 != "Link") { source[$10] = $3 "-" $4
                      out[$0] = $0 "|" }
    ($16 == "Link") { link[$0] = $22 }
    END {
      for (line in link) {
        out[line] = line "|" source[link[line]]
      }
      n = asort(out)
      for (i = 1; i <= n; i++) print out[i]
    }' "tmp/$FL.3" > "tmp/$FL.4"

  cat "tmp/$FL.4" \
    | sort -df -t "|" -k 1 -k 2 -k 3 -k 4n -k 13 -k 14 -k 10 \
    | sed 's=$=|=g' | sed 's=|0|=||=g' | sed 's=|0|=||=g' | sed 's=|\+$==g' \
    >> "$FL"

fi

echo "Maintainer|SRPM|RPM|EVR|Arch|File" > "$TSUM"
}


analyse() {

echo ""
echo "Conducting tests:"
echo ""


echo -n "— "
test_help outside-usr-share-fonts title }

awk -F '|' '(NR > 1) && ($16 != "Link") && ($24!="X") && \
            ($10 !~ /^\/usr\/share\/fonts\//)' "$FL" \
  | sort -df -t "|" > tmp/tmp.csv

list_rpm tmp/tmp.csv
test_wrapup outside-usr-share-fonts tmp/tmp.csv "$TSUM"


echo -n "— "
test_help without-rpm-metadata title

awk -F '|' '(NR > 1) && ($16 != "Link") && ($24!="X") && \
            ($7 != "M")' "$FL" \
  | sort -df -t "|" > tmp/tmp.csv

list_rpm tmp/tmp.csv
test_wrapup without-rpm-metadata tmp/tmp.csv "$TSUM"


echo -n "— "
test_help family-mixing title

awk -F '|' '
  (NR > 1) && ($11 != "") {
    rpm = $3 "-" $4 "." $5
    files[rpm] = files[rpm] $0 "#"
    if ( ! family[rpm] ) {
      family[rpm] = $11
    }
    else {
      if (family[rpm] != $11) {
        mixed[rpm] = 1
      }
    }
  }
  END {
    for (rpm in mixed) {
      sub("#$", "", files[rpm])
      split(files[rpm], lines,"#")
      for (l in lines) {
        print lines[l]
      }
    }
  }' "$FL" \
  | sort -df -t "|" > tmp/tmp.csv

list_rpm tmp/tmp.csv
test_wrapup family-mixing tmp/tmp.csv "$TSUM"


echo -n "— "
test_help duplicated-file title

awk -F '|' '
  (NR > 1) && ($24 != "X") && ($16 != "Link") {
    files[$18] = files[$18] $0 "#"
  }
  END {
    for (checksum in files) {
      sub("#$", "", files[checksum])
      count = split(files[checksum], lines,"#")
      if (count > 1) {
        for (l in lines) {
          print lines[l]
        }
      }
    }
  }' "$FL" \
  | sort -g -t "|" -k 18 > tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
awk -F '|' '
  {
    rpm = $3
    if ( $7 == "M" ) { rpm = "[" rpm "]" }
    sub(".*/", "", $10)
    print rpm "|" $18 "|" $10 "#(" $11 ", " $12 ")"
  }' tmp/tmp.csv | enum_rpm

test_wrapup duplicated-file tmp/tmp.csv "$TSUM"

echo -n "— "
test_help duplicated-face-ext title

awk -F '|' '
  (NR > 1) && ($11 != "") && ($12 != "") {
    face = $11 "|" $12
    rpm  = $3  "-" $4 "." $5
    files[face] = files[face] $0 "#"
    if ( ! loc[face] ) { loc[face] = rpm }
    else {
      if (loc[face] != rpm) {
        duplicated[face] = 1
      }
    }
  }
  END {
    for (face in duplicated) {
      sub("#$", "", files[face])
      split(files[face], lines,"#")
      for (l in lines) {
        print lines[l]
      }
    }
  }' "$FL" \
  | sort -df -t "|" -k 11 -k 12 > tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
awk -F '|' '
  {
    rpm = $3
    if ( $7 == "M" ) { rpm = "[" rpm "]" }
    sub(".*/", "", $10)
    print rpm "|" $11 ", " $12 "|" $10
  }' tmp/tmp.csv | enum_rpm

test_wrapup duplicated-face-ext tmp/tmp.csv "$TSUM"


echo -n "— "
test_help fc-query title

awk -F '|' '(NR > 1) && ($16 != "Link") && ($24!="X") && \
            ($15 == "")' "$FL" > tmp/tmp.csv

list_rpm tmp/tmp.csv
test_wrapup fc-query tmp/tmp.csv "$TSUM"


echo -n "— "
test_help libmagic title

awk -F '|' '(NR > 1) && ($16 != "Link") && ($24!="X") && \
            ($16 !~ /font/) && ($14 !~ /Font/)' "$FL" > tmp/tmp.csv

list_rpm tmp/tmp.csv
test_wrapup libmagic tmp/tmp.csv "$TSUM"


echo -n "— "
test_help broken-symlink title

awk -F '|' '(NR > 1) && ($16 == "Link") && ($23 == "")' "$FL" > tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
awk -F '|' '
  {
    rpm = $3
    if ( $7 == "M" ) { rpm = "[" rpm "]" }
    sub(".*/", "", $10)
    print rpm "|" $10 " ↛ " $22
  }' tmp/tmp.csv | enum_rpm

test_wrapup broken-symlink tmp/tmp.csv "$TSUM"

echo -n "— "
test_help rpmlint title

awk -F '|' '(NR > 1) && ($16 != "Link") && ($24 != "X") && \
            ($9 != "")' "$FL" > tmp/tmp.csv

list_rpm tmp/tmp.csv
test_wrapup rpmlint tmp/tmp.csv "$TSUM"


echo -n "— "
test_help mixed-with-non-font-data title

awk -F '|' '(NR > 1) && ($16 != "Link") && ($24 != "X") && \
            ($8 != "")' "$FL" > tmp/tmp.csv

list_rpm tmp/tmp.csv
test_wrapup mixed-with-non-font-data tmp/tmp.csv "$TSUM"


echo -n "— "
test_help arch-package title

awk -F '|' '(NR > 1) && ($16 != "Link") && ($24 != "X") && \
            ($5 != "noarch")' "$FL" > tmp/tmp.csv

list_rpm tmp/tmp.csv
test_wrapup arch-package tmp/tmp.csv "$TSUM"


echo -n "— "
test_help bad-rpm-naming title

awk -F "|" '(NR > 1) && ($16 != "Link") && ($24!="X") && \
            $3 !~ /^[0-9abcdefghijklmnopqrstuvwxyz\.-]*-fonts$/' "$FL" \
            > tmp/tmp.csv

list_rpm tmp/tmp.csv
test_wrapup bad-rpm-naming tmp/tmp.csv "$TSUM"


echo -n "— "
test_help bad-naming title

awk -F '|' '(NR > 1) && ( ($11!=$13) || ($12!=$14))' "$FL" > tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
awk -F '|' '
  {
    rpm = $3
    if ( $7 == "M" ) { rpm = "[" rpm "]" }
    sub(".*/", "", $10)
    print rpm "|" $11 ", " $12 " → " $13 ", " $14 "|" $10
  }' tmp/tmp.csv | enum_rpm

test_wrapup bad-naming tmp/tmp.csv "$TSUM"


echo -n "— "
test_help core-fonts title

awk -F '|' '(NR > 1) && ($24=="X")' "$FL" > tmp/tmp.csv

list_rpm tmp/tmp.csv
test_wrapup core-fonts tmp/tmp.csv "$TSUM"


echo -n "— "
test_help font-linking title

awk -F '|' '(NR > 1) && ($16=="Link")' "$FL" > tmp/tmp.csv

list_rpm tmp/tmp.csv
test_wrapup font-linking tmp/tmp.csv "$TSUM"


echo -n "— "
test_help duplicated-face-int title

awk -F '|' '
  (NR > 1) && ($24!="X") && \
    ($15 != "PCF") && ($15 != "Type 1") && \
    ($11 != "") && ($12 != "") {
    sig = $3 "|" $4 "|" $5 "|" $11 "|" $12
    files[sig] = files[sig] $0 "#"
  }
  END {
    for (sig in files) {
      sub("#$", "", files[sig])
      n = split(files[sig],lines,"#")
      if (n > 1) {
        for (l in lines) { print lines[l] }
      }
    }
  }' "$FL" \
  | sort -df -t "|" -k 11 -k 12 -k 3 -k 2 > tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
awk -F '|' '
  {
    rpm = $3
    if ( $7 == "M" ) { rpm = "[" rpm "]" }
    sub(".*/", "", $10)
    print rpm "|" $11 ", " $12 "|" $10
  }' tmp/tmp.csv | enum_rpm

test_wrapup duplicated-face-int tmp/tmp.csv "$TSUM"


echo -n "— "
test_help fontlint title

awk -F '|' '(NR > 1) && ($24!="X") && ($21 > 0)' "$FL" > tmp/tmp.csv

list_rpm tmp/tmp.csv
test_wrapup fontlint tmp/tmp.csv "$TSUM"


echo -n "— "
test_help no-english-metadata title

awk -F '|' '(NR > 1) && ($24!="X") && \
            ($15 != "") && (($11 == "") || ($12 == ""))' "$FL" > tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
awk -F '|' '
  {
    rpm = $3 "-" $4 "." $5
    if ( $7 == "M" ) { rpm = "[" rpm "]" }
    print $10 "|" rpm
  }' tmp/tmp.csv \
  | column -t -s '|' | pretty_indent

test_wrapup no-english-metadata tmp/tmp.csv "$TSUM"


echo -n "— "
test_help partial-scripts title

awk -F '|' '(NR > 1) && ($24!="X") && ($19 > 0)' "$FL" > tmp/tmp.csv

list_rpm tmp/tmp.csv
test_wrapup partial-scripts tmp/tmp.csv "$TSUM"


echo -n "— "
test_help partial-blocks title

awk -F '|' '(NR > 1) && ($24!="X") && ($20 > 0)' "$FL" > tmp/tmp.csv

list_rpm tmp/tmp.csv
test_wrapup partial-blocks tmp/tmp.csv "$TSUM"
}


sum_up() {
echo ""
echo "Audit results:"
echo ""

echo "– packages that declare font metadata:"

awk -F '|' '(NR > 1) && ($7 == "M") && ($24!="X")' "$FL" > tmp/tmp.csv
stats tmp/tmp.csv

echo "☛ File size is computed as extracted, while rpm is a compressed \
format." | pretty_indent
echo "☛ Mid-term, files in legacy PCF or Type1 formats need to be converted \
or removed." | pretty_indent
echo ""

echo "– font files in other packages (we should not find any!)"

awk -F '|' '(NR > 1) && ($7 != "M") && ($16 != "Link") && ($24!="X")' "$FL" > tmp/tmp.csv
stats tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
echo "☛ Bad packaging may result in arched packages or mixed content." \
| pretty_indent && echo ""

echo "– errors, warnings and suggestions:"
echo ""

test_score "$TSUM"

}


prepare_spam() {
echo ""
echo "Packing mail data…"

mkdir spam

for srpm in $(awk -F '|' 'FNR>1 { print $2 }' "$TSUM" | uniq) ; do
  mkdir "tmp/$srpm"
  cp -p report.txt "tmp/$srpm/repo-report.txt"
  for file in "$FL" "$TSUM" ; do
    awk 'FNR==1' "$file" > "tmp/$srpm/$file"
    awk -F '|' -v srpm="$srpm" 'FNR>1 && $2==srpm' "$file" >> "tmp/$srpm/$file"
  done
  for rpm in $(awk -F '|' 'FNR>1 { print $3 "-" $4 "." $5 }' "tmp/$srpm/$TSUM" | uniq | sed "s+$bad_pattern+_+g") ; do
    cp -pr "data/$rpm" "tmp/$srpm"
  done
  cat > tmp/$srpm/message.txt << EOF
Dear packager,

At $TIMESTAMP, your “$srpm” package failed one or more of the tests
I was performing on the “$ID” repository located at:
$REPOURL

There are three different reasons that may cause this message:
1. your package is including one or more font files, but not packaging
   them properly;
2. your package is including one or more font files, and I've found
   issues in some of them;
3. your package is not shipping any font file, but the way it accesses
   fonts in other packages is not satisfying.

To stop receiving this message, you need to:
1. drop the font files or fix their packaging;
2. relay the fonts issues to the fonts upstream to get them revised;
3. work with the code upstream to improve the way it accesses font
   files (usually by making it use fontconfig through a higher-level
   text library such as pango, pango-cairo, harfbuzz, or QT)

You can self-check your packages at any time by:
1. installing createrepo and fontpackages-tools:
# yum install createrepo fontpackages-tools
2. putting your packages and any font package they depends on in a
   test directory
3. indexing this directory with createrepo:
$ createrepo path-to-test-directory
4. running repo-font-audit:
$ repo-font-audit test file://absolute-path-to-test-directory

A summary of the issues I detected is appended here. For your
convenience a more comprehensive analysis is also attached to this
message.

Errors, warnings and suggestions:

$(test_score "tmp/$srpm/$TSUM")

Please take the appropriate measures to fix the “$srpm” package.
I will warn you again if it is still necessary next time I am ran.

This report was generated by the repo-font-audit command from:
http://fedoraproject.org/wiki/fontpackages

Please post questions, suggestions, patches or bug reports to:
https://www.redhat.com/mailman/listinfo/fedora-fonts-list
(subscription required)

Your friendly QA robot,

-- 
repo-font-audit
EOF
  cd tmp
  tar cf "$srpm.tar" "$srpm"
  cd ..
  xz -9  "tmp/$srpm.tar"
  mv "tmp/$srpm.tar.xz" spam
done
cat > spam/send-messages.sh << EOF
#!/bin/sh
# Send warnings to problem package owners
# This is a bit distribution-specific, people from other distributions are
# welcome to suggest how to make it more agnostic

#EMAIL="repo-font-audit <your@mail>"
#REPLYTO=another@mail

#export EMAIL REPLYTO

for srpm in \\
$(awk -F '|' 'FNR>1 { print $1 " \\" }' "$TSUM" | uniq)
; do
  tar -xf \$srpm.tar.xz */message.txt -O \\
    | mutt -s "[RFA] Your \$srpm $ID package did not pass QA!" \\
           -a \$srpm.tar.xz -- \$srpm-owner@fedoraproject.org
  sleep 5
done

EOF
chmod +x spam/send-messages.sh
}

pack_data() {
echo "Packing result data…"


mv spam "$SPAM"

mkdir -p "$RES/data"
cp "$TSUM" summary.txt report.txt "$FL" "$RES/"
cp -pr data/* "$RES/data" 2>/dev/null

mkdir "$SRES/"
cp "$TSUM" summary.txt report.txt "$SRES/"

for report in "$RES" "$SRES" "$SPAM" ; do
  tar cf "$report.tar" "$report"
  xz -9  "$report.tar"
  mv "$report.tar.xz" "$ORIGDIR/"
done

echo ""
echo "Audit complete!"

awk 'NR > 1' "$FL" > "tmp/$FL"

(
cat << EOF

Number of items processed:
$(summary "tmp/$FL")

1. Extracted data: $ORIGDIR/$RES.tar.xz
2. Short summary: $ORIGDIR/$SRES.tar.xz
3. Mail data: $ORIGDIR/$SPAM.tar.xz

This report was generated by the repo-font-audit command from:
http://fedoraproject.org/wiki/fontpackages

Please post questions, suggestions, patches or bug reports to:
https://www.redhat.com/mailman/listinfo/fedora-fonts-list
(subscription required)
EOF
) | pretty_indent

}

# End of function declarations

[ "$#" -lt "2" ] && usage

TIMESTAMP=$(date -u +%Y%m%dT%H%M%SZ)
ID=$1
REPOID="$1-rfa-$TIMESTAMP"
REPOURL=$2
ORIGDIR="$PWD"

FPL="font-packages.csv"
PWFL="packages-with-fonts.csv"
XPL="package-using-x11.csv"
CSL="checksums.csv"
FL="consolidated-data.csv"
TSUM="test-summary.csv"
RES="repo-font-audit-$ID-$TIMESTAMP"
SRES="repo-font-audit-$ID-$TIMESTAMP-short"
SPAM="repo-font-audit-$ID-$TIMESTAMP-mail"

TMPDIR=$(mktemp -d --tmpdir=/tmp $RES-XXXXXXXXXX)
cd $TMPDIR

mkdir tmp

collect
consolidate
analyse | tee report.txt
sum_up  | tee summary.txt
prepare_spam
pack_data

cd "$ORIGDIR"
rm -fr "$TMPDIR"
echo "♻"
