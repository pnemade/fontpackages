#!/bin/bash
# Quick and dirty script to audit font repartition in a yum package repository
#
# It is slow, it is ugly, and it requires a good network connection

# Function declarations

usage() {
cat >&2 << EOF_USAGE
Usage: $0 <id> <location>
<id>:       identifier of the package repository to check
<location>: location of the package repository to check

Examples:
$0 tmp file:///tmp/rpm
$0 rawhide http://example.com/mirrors/fedora.redhat.com/fedora/linux/development/x86_64/os/

EOF_USAGE
exit 1
}


# FIXME: only extracts info about the first typeface in a TTC file for now
parse_localized_fc_query() {
  field="$1"
  file="$2"
  fieldstring=$(awk -F ':' -v field="$field" \
                    '$1 == "\t"field { print $2 ; exit }' "$file" \
               | sed 's="(s)="=g' | sed 's=" *"=|=g'| sed 's= *" *==g')"|"
  default=$(echo $fieldstring | awk -F "|" '{ print $1 }')
  if $(grep -q "^"$'\t'$field"lang:" "$file") ; then
    langstring=$(awk -F ':' -v field="$field" \
                '$1 == "\t"field"lang" { print $2 ; exit }' "$file" \
                | sed 's="(s)="=g' | sed 's=" *"=|=g'| sed 's= *" *==g')"|"
    # Try to find the English label
    while [ "$langstring" != "" -a \
            "$(echo $langstring | awk -F '|' '{ print $1 }')" != "en" ] ; do
      fieldstring=$(echo "$fieldstring" | sed 's+\([^|]*\)|\(.*\)+\2+g')
      langstring=$(echo "$langstring" | sed 's+\([^|]*\)|\(.*\)+\2+g')
    done
    # We could hide problems by reporting the first label regardless of its
    # language. But this is an audit script — we do not hide problems
    echo "$fieldstring" |  awk -F "|" '{ print $1 }'
    if [ "$fieldstring" == "" ] ; then  echo -ne "\b‽" >&2 ; fi
  else
    echo $(echo $fieldstring | awk -F "|" '{ print $1 }')
  fi
}


pretty_indent() {
  fold -s -w $(($(tput cols) - 4)) \
  | while read line ; do echo "    $line" ; done
  echo ""
}


tally() {
t_datafile=$1

t_file=$(cat "$t_datafile" | wc -l)
t_file_size=$(awk -F '|' '{ sum += $14 } END { print sum }' "$t_datafile")
t_file_size=$((t_file_size/(1024*1024)))

t_rpm=$(awk -F '|' '{ print $2 "-" $3 "." $4 }' "$t_datafile" \
        | sort | uniq | wc -l)
t_rpm_size=$(awk -F '|' '{ print $2 "-" $3 "." $4 "|" $5 }' "$t_datafile" \
             | sort | uniq \
            |awk -F '|' '{ sum += $2 } END { print sum }')
t_rpm_size=$((t_rpm_size/(1024*1024)))

t_srpm=$(awk -F '|' '{ print $1 }' "$t_datafile" | sort | uniq | wc -l)

echo "$t_file|$t_rpm|$t_srpm|$t_file_size|$t_rpm_size"
}


summary() {
if [ $(cat "$1" | wc -l) -gt 0 ] ; then
  tally "$1" | awk -F '|' '{ print "⇒ " $1 " file(s) (" $4 " MiB) in " $2 \
        " package(s) (" $5 " MiB) generated from " $3 " source package(s)." }'\
        | pretty_indent
else
  echo "⇒  None!" | pretty_indent
fi
}


# $1 = summary file
# $2 = temporary data file
# $3 = test id
complete_csv_summary() {
  awk -F '|' -v t_datafile="$2" -v testlabel="$3" \
      'FILENAME==t_datafile { fail[$1"|"$2"|"$9] = 1 }
       FILENAME!=t_datafile && FNR==1 {
        max = NF + 1
        header = $1
        for (i = 2 ; i <= max ; i++) {
           header = header "|" $i
         }
        print header testlabel
       }
       FILENAME!=t_datafile && FNR>1 {
         line = $1 "|" $2 "|" $3
         newline = $1
         for (i = 2 ; i <= max ; i++) {
           newline = newline "|" $i
         }
         print newline fail[line]
         processed[line] = 1
       }
       END {
         for ( line in fail ) {
           if ( ! processed[line] ) {
             newline = line
             for (i = 4 ; i <= max ; i++) {
               newline = newline "|"
             }
             print newline fail[line]
           }
         }
       }' "$2" "$1" > tmp/tmp.ccs.csv
  awk 'FNR==1' tmp/tmp.ccs.csv > "$1"
  awk 'FNR>1'  tmp/tmp.ccs.csv | sort -f -t '|' >> "$1"
  rm tmp/tmp.ccs.csv
}


substats() {
ss_datafile="$1"

awk -F '|' '{ print $NF }' "$ss_datafile" | sort | uniq \
  | while read key ; do
    echo -n "$key|"
    awk -F '|' -v key="$key" '$NF==key' "$ss_datafile" > tmp/tmp.ss.csv
    tally tmp/tmp.ss.csv
    rm tmp/tmp.ss.csv
  done
}


stats() {
s_datafile="$1"

summary "$s_datafile"

if [ $(cat "$s_datafile" | wc -l) -gt 0 ] ; then
  (echo "Format|Files|rpm|srpm|Files (MiB)|rpm (MiB)"
  awk -F '|' '$12 != "" { print $0 "|" $12 }' "$s_datafile" > tmp/tmp.s.csv
  substats tmp/tmp.s.csv) | column -t -s '|' | pretty_indent

  (echo "Format|Files|rpm|srpm|Files (MiB)|rpm (MiB)"
  awk -F '|' '{ print $0 "|" $4 }' "$s_datafile" > tmp/tmp.s.csv
  substats tmp/tmp.s.csv)| column -t -s '|' | pretty_indent

  rm tmp/tmp.s.csv
fi
}


list-rpm() {
if [ $(cat "$1" | wc -l) -gt 0 ] ; then
  awk -F '|' '{ if ( $6 == "M" ) print "[" $2 "]" ; \
                            else print     $2     }' "$1" | sort | uniq \
    | awk -F '|' '{ list = list " " $1 } END { print list }' | pretty_indent
fi
}


canonalise_and_invert_string() {
  cais=""
  for token in $(echo "$@" | sed "s=[ \t_\.-]\+= =g" | sed "s=^ ==g" \
                           | sed "s= $==g") ; do
      cais="$token $cais"
  done
  echo " $cais"
}


wws_resolve () {
cais_name=$(canonalise_and_invert_string $1)
result="$cais_name"
patterns=""
for pattern in $2 ; do patterns="$pattern $patterns" ; done
for pattern in $patterns ; do
   pattern=$(canonalise_and_invert_string $pattern)
   tmp=$(echo "$cais_name" | sed "s=$pattern= =i")
   [ "$tmp" != "$cais_name" ] && result="$tmp"
done
result=$(canonalise_and_invert_string "$result" \
         | sed "s=^ ==" | sed "s= $==")
echo "$result"
}


# $1 test id
# $2 "title" of "help"
test_help() {
case "$1" in
 "outside-usr-share-fonts")
    case "$2" in
      "title")
        echo "Error: fonts deployed outside /usr/share/fonts"
        ;;
      "help")
        cat << EOF
Packager task

The standard location for font files is under the /usr/share/fonts root
(default fontconfig setting). Please simplify the work of font utilities
and use it exclusively. It is always possible to symlink font files
somewhere else on the file-system if an application requires it.

If you fear exposing your font files in fontconfig will cause problems,
please work with the fontconfig maintainers to resolve them.
EOF
        ;;
    esac
    ;;
  "without-rpm-metadata")
    case "$2" in
      "title")
        echo "Error: fonts in packages that do not declare font metadata"
        ;;
      "help")
        cat << EOF
Packager task

Font-specific rpm metadata is required for automatic font installation to
work. If you apply our font packaging templates, it will be generated at
package creation time.
EOF
        ;;
    esac
    ;;
  "family-mixing")
    case "$2" in
      "title")
        echo "Error: packages that mix different font families"
        ;;
      "help")
        cat << EOF
Packager task

Reliable font auto-installation requires shipping only one font family per
font package.

(If you've remapped some font names at the fontconfig level your package
may appear here pending some fontconfig fixes upstream is aware of).
EOF
        ;;
    esac
    ;;
  "duplicated-file")
    case "$2" in
      "title")
        echo "Error: exact font duplication"
        ;;
      "help")
        cat << EOF
Packager task, eventual upstream task

Several packages duplicate font files with the same checksum. This
needlessly wastes resources infrastructure and user side  and makes font
maintenance problematic.

A repository should always include only one version of a font file.

This test can not discriminate between packages and identity the correct
owner of the font files. His maintainer will be blamed with others. If
you're not him it is therefore unfriendly not to fix this error as soon as
you can.

It is always possible to reuse a font file packaged separately by adding a
dependency on the other package providing it, and accessing the font
through fontconfig.

If an application can not use fontconfig today this is a serious bug that
should be reported to the application upstream. Please ask it to add
fontconfig support to their code (possibly, via a higher-level library
such as pango-cairo). However it can workarounded by the packager with
symlinks (that will need maintenance).
EOF
        ;;
    esac
    ;;
  "duplicated-face-ext")
    case "$2" in
      "title")
        echo "Error: font faces duplicated by different packages"
        ;;
      "help")
        cat << EOF
Packager task, eventual upstream task

Several packages duplicate font files with the same face name. This
needlessly wastes resources infrastructure and user side and makes font
maintenance problematic:

1. Very often an upstream that copied some fonts will forget to keep them
up to date, and the duplication will result in the distribution of old
buggy data.

2. Shipping the same font in different formats is also problematic:
different font formats have different features, and are processed by
different font libraries. It is almost impossible to create a font in
multiple formats that will all behave the same. Users hate fonts that do
not behave consistently everywhere.

3. Most of our applications use fontconfig to access fonts, and fontconfig
uses font names to identify files. Naming collisions make font selection
unreliable. So even genuine forks with different features from the
original are a problem if not renamed.

A repository should always include only one version of a font face.

This test can not discriminate between packages and identity the correct
owner of the font face. His maintainer will be blamed with others. If
you're not him it is therefore unfriendly not to fix this error as soon as
you can.

It is always possible to reuse a font file packaged separately by adding a
dependency on the other package providing it, and accessing the font
through fontconfig.

If an application can not use fontconfig today this is a serious bug that
should be reported to the application upstream. Please ask it to add
fontconfig support to their code (possibly, via a higher-level library
such as pango-cairo). However it can workarounded by the packager with
symlinks (that will need maintenance).

If an application can not use a modern font format and forces the
re-packaging in an older format of an exiting font this is an application
bug that should be reported to the application upstream. In that case
these is no good solution possible baring the fixing of the application.
EOF
        ;;
    esac
    ;;
  "fc-query")
    case "$2" in
      "title")
        echo "Error: fonts fc-query can not parse"
        ;;
      "help")
        cat << EOF
Upstream task

fc-query could not parse some font files in the package. The files may be
malformed and in need of fixing, or fc-query has a bug.

Any font file rejected by fc-query will be useless in fontconfig and most
applications. If it can not be fixed drop it

Please relay the problem to the appropriate upstream to get it fixed.
EOF
        ;;
    esac
    ;;
  "libmagic")
    case "$2" in
      "title")
        echo "Error: fonts not identified as such by libmagic"
        ;;
      "help")
        cat << EOF
Upstream task

libmagic could not identify some files with font-like extensions in the
package. The files may be malformed and in need of fixing, or they use a
font extension when they should not, or libmagic has a bug.

Please relay the problem to the appropriate upstream to get it fixed.
EOF
        ;;
    esac
    ;;
  "broken-symlink")
    case "$2" in
      "title")
        echo "Error: broken symlinks to font files"
        ;;
      "help")
        cat << EOF
Packager and upstream task

The symlinked font file has moved, been renamed, or the symlink was never
properly set up. You need to change the symlink.

Symlinking requires maintenance and is only necessary when an application
lacks fontconfig support. If an application can not use fontconfig today
this is a serious bug that should be reported to the application upstream.
Please ask it to add fontconfig support to their code (possibly, via a
higher-level library such as pango-cairo).
EOF
        ;;
    esac
    ;;
  "rpmlint")
    case "$2" in
      "title")
        echo "Error: rpmlint"
        ;;
      "help")
        cat << EOF
Packager task

Check rpmlint output to fix the listed packages (using the -i flag if you
don't understand rpmlint messages).
EOF
        ;;
    esac
    ;;
  "mixed-with-non-font-data")
    case "$2" in
      "title")
        echo "Error: fonts in packages that contain non-font data"
        ;;
      "help")
        cat << EOF
Packager task

Please do not mix font files with non-font data in packages. Fonts are
usually useful outside of the package that deploys them and should be
installable without pulling in other material.
EOF
        ;;
    esac
    ;;
  "arch-package")
    case "$2" in
      "title")
        echo "Error: fonts in arch packages"
        ;;
      "help")
        cat << EOF
Packager task

Fonts are not arch-specific; please make sure they are deployed in noarch
packages.
EOF
        ;;
    esac
    ;;
  "bad-rpm-naming")
    case "$2" in
      "title")
        echo "Warning: fonts in packages that do not respect font naming conventions"
        ;;
      "help")
        cat << EOF
Packager task

Please respect font package naming conventions and provide consistent
packages to users. Some scripts may depend on strict package naming.
EOF
        ;;
    esac
    ;;
  "bad-family-naming")
    case "$2" in
      "title")
        echo "Warning: fonts that declare style attributes in family names"
        ;;
      "help")
        cat << EOF
Font upstream task, with packager workarounds

This test checks if font family names do not include WWS “Width
(Stretch)”, “Weight”, “Slope (Slant/Style)” face qualifiers¹. To be
properly processed by applications those qualifiers need to be declared in
style names.

Since *nix applications do not workaround bad font naming with dynamic
renaming heuristics (unlike Microsoft WPF), achieving consistent naming
requires fixing it directly in the font files. For this reason we test
font family naming separately from font style naming.

To pass this test make sure font names do not include any “Width
(Stretch)”, “Weight”, “Slope (Slant/Style)” qualifier defined in the WWS
whitepaper¹.


If one your font files is listed here please ask its upstream to fix its
naming so it respects WWS conventions and does not need further
reprocessing. (There may be a few false positives in this test as some
common face qualifiers can be used with a different meaning in family
names.)

Packager workaround: patch the file (if it is available in .sfd format),
or add a fontconfig rule to your package to hide the problem².

¹ http://blogs.msdn.com/text/attachment/2249036.ashx
  http://blogs.adobe.com/typblography/typotechnica2007/Font%20names.pdf
  http://blogs.adobe.com/typblography/atypi2006/CSS%20&%20OT%2015.pdf
² cf the “fontpackages” remapping template; unfortunately this workaround
  won't fix problems for non-fontconfig applications, or when
  interoperating with other systems.
EOF
        ;;
    esac
    ;;
  "bad-style-naming")
    case "$2" in
      "title")
        echo "Warning: fonts that declare non-WWS compliant styles"
        ;;
      "help")
        cat << EOF
Font upstream task, with packager workarounds

This WWS-like test checks if font styles use the WWS “Width (Stretch)”,
“Weight”, “Slope (Slant/Style)” naming convention¹. As noted by Adobe² the
W3C CSS font family model is less than ideal, but it is a standard and
applications expect it.

Since *nix applications do not workaround bad font naming with dynamic
renaming heuristics (unlike Microsoft WPF), achieving consistent naming
requires fixing it directly in the font files. For this reason we test
font style naming separately from font family naming, and do not support
complex weight abbreviations and suffixes³.

To pass this test make sure style names do not include any qualifier not
defined in the WWS white-paper¹, and that “Width (Stretch)”, “Weight”,
“Slope (Slant/Style)” are defined only once. Any other face qualifier
belongs in the font family name.

If one your font files is listed here please ask its upstream to fix its
naming so it respects WWS conventions and does and does not need further
reprocessing.

Packager workaround: patch the file (if it is available in .sfd format),
or add a fontconfig rule to your package to hide the problem⁴.

¹ http://blogs.msdn.com/text/attachment/2249036.ashx
  http://blogs.adobe.com/typblography/typotechnica2007/Font%20names.pdf
² http://blogs.adobe.com/typblography/atypi2006/CSS%20&%20OT%2015.pdf
³ As defined in the end of the WWS renaming algorithm described in the
  Microsoft whitepaper.
⁴ cf the “fontpackages” remapping template; unfortunately this workaround
  won't fix problems for non-fontconfig applications, or when
  interoperating with other systems.
EOF
        ;;
    esac
    ;;
  "core-fonts")
    case "$2" in
      "title")
        echo "Warning: core fonts use"
        ;;
      "help")
        cat << EOF
Upstream task

This package accesses fonts through the X11 Core protocol.

Numerous long-standing problems with this mode of access, and a design
that could not scale to modern font needs lead the (then XFree86) team to
deprecate it in favour of fontconfig (née xft). Adoption was quick and by
2003 it was clear fontconfig was the new standard¹. Nowadays fontconfig is
widely used², including on non Linux/Unix platforms.

While X11 Core access has been kept on life-support this font system is
not actively maintained today. The font library it depends on is slowly
shrinking, as it was created in a period of different legal and technical
requirements², and there is no one to update the font files when a problem
is found³. Therefore, projects are advised to migrate before the situation
reaches a critical stage.

Fontconfig has been our default font system for a long time, and accessing
fonts by other means will cause behaviour inconsistencies and many other
problems (since fontconfig can be used to change the behaviour of a font).

If an application can not use fontconfig today this is a serious bug that
should be reported to the application upstream. Please ask it to add
fontconfig support to their code (possibly, via a higher-level library
such as pango-cairo).


¹ http://xfree86.org/pipermail/forum/2003-March/000799.html
² Screen technology changed, encoding standard (Unicode) changed, legal
reviews became more comprehensive, etc.
³ Leaving culling the only solution.
EOF
        ;;
    esac
    ;;
  "font-linking")
    case "$2" in
      "title")
        echo "Warning: font linking"
        ;;
      "help")
        cat << EOF
Upstream task

Symlinking is a way for non-font packages to avoid duplicating font files,
but it is also a symptom of missing or incomplete fontconfig support.

Fontconfig has been our default font system for a long time, and accessing
fonts by other means will cause behaviour inconsistencies and many other
problems (since fontconfig can be used to change the behaviour of a font).

If an application can not use fontconfig today this is a serious bug that
should be reported to the application upstream. Please ask it to add
fontconfig support to their code (possibly, via a higher-level library
such as pango-cairo).
EOF
        ;;
    esac
    ;;
  "duplicated-face-int")
    case "$2" in
      "title")
        echo "Warning: font faces duplicated within a package"
        ;;
      "help")
        cat << EOF
Packager or upstream task

Face duplication within a package is almost certainly a bug (usually,
mis-naming in one of the font files), except for special symbol font
families.

1. Fonts that were split because of the limitations of legacy font formats
(PCF, Type 1…) should be converted to modern OpenType (TT, CFF or bitmap)
containers.

2. Shipping the same font in different formats is problematic: different
font formats have different features, and are processed by different font
libraries. It is almost impossible to create a font in multiple formats
that will all behave the same. Users hate fonts that do not behave
consistently everywhere.

3. Most of our applications use fontconfig to access fonts, and fontconfig
uses font names to identify files. Naming collisions make font selection
unreliable.

If an application can not use a modern font format and forces the
re-packaging in an older format of an exiting font this is an application
bug that should be reported to the application upstream. In that case
these is no good solution possible baring the fixing of the application.
EOF
        ;;
    esac
    ;;
  "fontlint")
    case "$2" in
      "title")
        echo "Warning: fonts that do not pass fontlint sanity checks"
        ;;
      "help")
        cat << EOF
Font upstream task

Fontforge's fontlint¹ test suite found problems in some files included in
the package. Those problems may not be obvious and only manifest as
strange behaviour in specific applications (making them hard to debug).
For that reason it is recommanded to report those problems upstream and
get them fixed, even if the font file seems to work fine most of the time.

You can ask help about specific fontlint errors on:
https://lists.sourceforge.net/lists/listinfo/fontforge-users

Please relay the problem report to the font upstream.

¹ http://fontforge.sourceforge.net/fontlint.html
EOF
        ;;
    esac
    ;;
  "no-english-metadata")
    case "$2" in
      "title")
        echo "Warning: fonts with localized metadata but no English variant"
        ;;
      "help")
        cat << EOF
Font upstream task

Some font files in the package declare localized metadata, but do not
include an English variant. They need to be fixed to also declare metadata
in English, so it can be used in technical declarations such as CSS rules.
(Sometimes font do include English metadata, but under another language
label. There is no way for applications or for this test to guess some
metadata is mislabeled).

Please relay the problem report to the font upstream.
EOF
        ;;
    esac
    ;;
  "partial-scripts")
    case "$2" in
      "title")
        echo "Suggestion: fonts with partial script coverage"
        ;;
      "help")
        cat << EOF
Font upstream task

Some font files included in the package are missing a few glyphs to be
accepted by fontconfig as covering one or several scripts. Therefore they
could be made useful to more people with only a little effort.

Many scripts differ by only a few glyphs and it is unfortunately common
for font authors not to notice they stopped just short of full support for
some of them.

To check a font file script coverage, run:
  $ FC_DEBUG=256 fc-query font-file
and look for lines like:
  script-id¹(number) { list-of-unicode-codepoints }

For example
  “mi(2) { 1e34 1e35 }”
means fontconfig will accept the tested file for Maori if codepoints 1e34
and 1e35 are added.

fontconfig is used by a lot of applications on many systems so ignoring
its opinion on a font is a mistake.

Please relay the incomplete coverage report to the font upstream.

P.S.
Of course fontconfig is not perfect either so it may require a glyph for a
script when it should not. In that case, please report the problem to
fontconfig upstream:
https://bugs.freedesktop.org/enter_bug.cgi?product=fontconfig
against the “orth” component.

¹ http://www.loc.gov/standards/iso639-2/php/code_list.php
² https://bugs.freedesktop.org/enter_bug.cgi?product=fontconfig
EOF
        ;;
    esac
    ;;
  "partial-blocks")
    case "$2" in
      "title")
        echo "Suggestion: fonts with partial unicode block coverage"
        ;;
      "help")
        cat << EOF
Font upstream task

Some font files included in the package are missing only a few glyphs to
fully cover an Unicode block. Therefore they could be made useful to more
people with only a little effort.

The Unicode consortium revises its tables regularly. A font may need to be
extended to maintain full coverage of a block when a new Unicode standard
revision is published¹.

To check the unicode coverage of a font, run the ttfcoverage command. (It
only works for modern .otf or .ttf fonts).

Please relay the incomplete coverage report to the font upstream.

¹ http://www.unicode.org/charts/
EOF
        ;;
    esac
    ;;
 *)
    echo "Unknown test."
    ;;
esac
}


# $1 this test id
# $2 csv file with the results of this test
# $3 csv file that consolidates the results of all tests
test_wrapup() {

complete_csv_summary "$3" "$2" "$1"
summary "$2"

[ $(cat "$2" | wc -l) -gt 0 ] && \
( echo -n "☛ " ; test_help "$1" help ) | pretty_indent

}


# $1 csv with test results
test_score() {
if [ $(cat "$1" | wc -l) -gt 1 ] ; then
  (
    awk -F '|' '
      FNR==1 {
        max = NF
      }
      FNR>1 {
        id = $1 "|" $2
        fail[id] = 1
        for (i = 4 ; i <= max ; i++) {
          score[id"|"i] = score[id"|"i] + $i
          totalscore[i] = totalscore[i] + $i
        }
      }
      END {
        headerline = "SRPM|RPM"
        for (i = 4 ; i <= max ; i++) {
          if ( totalscore[i] ) { headerline  = headerline "|" i-3 }
        }
        print headerline
        n = asorti(fail)
        for (l = 1; l <= n; l++) {
          newline = fail[l]
          for (c = 4 ; c <= max ; c++) {
            if ( totalscore[c] ) {
              if ( score[fail[l]"|"c] )
                { newline = newline "|" score[fail[l]"|"c] }
              else
                { newline = newline "|‧" }
            }
          }
          print newline
        }
        totalline = " |Total"
        for (i = 4 ; i <= max ; i++) {
          if ( totalscore[i] ) { totalline = totalline "|"  totalscore[i] }
        }
        print totalline
      }' "$1"
  ) | column -t -s '|'

  awk -F '|' '
    FNR==1 {
      max = NF
      for (i = 4 ; i <= max ; i++) {
        legend[i] = i-3 "|" $i }
      }
    FNR>1 {
      for (i = 4 ; i <= max ; i++) {
        totalscore[i] = totalscore[i] + $i
      }
    }
    END {
      for (i = 4 ; i <= max ; i++) {
        if ( totalscore[i] ) { print legend[i] }
      }
    }' "$1" | while read line ; do
      echo ""
      testnumber=$(echo $line | awk -F '|' '{ print $1 }')
      testid=$(echo $line | awk -F '|' '{ print $2 }')
      echo -n "$testnumber. "
      test_help $testid title
      echo ""
      ( echo -n "☛ " ; test_help $testid help ) | pretty_indent
    done

else
  echo "⇒  None!"
fi

}


collect() {
echo "▶▶▶ Searching for packages with font metadata…"
repoquery --repofrompath=$REPOID,$REPOURL --repoid=$REPOID \
          --qf "%{sourcerpm}|%{name}|%{epoch}:%{version}-%{release}|%{arch}|%{packagesize}|M" \
          --whatprovides "font(*)" --quiet \
          | sort | uniq \
          | sed 's=^\([^|]\+\?\)\-\([^-|]\+\?\)\-\([^-|]\+\?\)|=\1|=g' \
          > "$FPL"

echo "▶▶▶ Searching for packages that include files with common font extensions…"
repoquery --repofrompath=$REPOID,$REPOURL --repoid=$REPOID \
          --qf "%{sourcerpm}|%{name}|%{epoch}:%{version}-%{release}|%{arch}|%{packagesize}|E" \
          -f '*.ttf' -f '*.otf' -f '*.ttc' \
          -f '*.pfb' -f '*.pfa' \
          -f '*.pcf.gz' -f '*.pcf' -f '*.bdf' --quiet \
          | sort | uniq \
          | sed 's=^\([^|]\+\?\)\-\([^-|]\+\?\)\-\([^-|]\+\?\)|=\1|=g' \
          > "$PWFL"

echo "▶▶▶ Searching for packages that use the core X11 protocol…"
repoquery --repofrompath=$REPOID,$REPOURL --repoid=$REPOID \
          --qf "%{sourcerpm}|%{name}|%{epoch}:%{version}-%{release}|%{arch}|%{packagesize}|X" \
          --whatrequires 'libX11.so*' \
          | sort | uniq \
          | sed 's=^\([^|]\+\?\)\-\([^-|]\+\?\)\-\([^-|]\+\?\)|=\1|=g' \
          > "$XPL"

if [ $(cat "$FPL" "$PWFL" "$XPL" | wc -l) -eq 0 ] ; then
  echo "Nothing to do!"
  exit
fi

cat "$FPL" "$PWFL" "$XPL" \
  | awk -F '|' '
      { tag[$1 "|" $2 "|" $3 "|" $4 "|" $5] = tag[$1 "|" $2 "|" $3 "|" $4 "|" $5] $6 "," }
      END {
        n =  asorti(tag,rpm)
        for (l = 1; l <= n; l++) {
          sub(/,$/, "", tag[rpm[l]])
          print rpm[l] "|" tag[rpm[l]]
        }
      }' > "tmp/$FL.1"


echo "▶▶▶ Inspecting packages:"
cd "tmp"
rm -f "$FL.2"

cat "$FL.1" | while read line ; do
  rpm=$(echo $line | awk -F '|' '{ print $2 "-" $3 "." $4 }')
  rpmline=$(echo $line | awk -F '|' '{ print $1 "|" $2 "|" $3 "|" $4 "|" $5 }')
  echo $line | cut -d "|" -f 6 | grep -q "M" \
    && metadata="M" || metadata=""
  echo -n " – $rpm"
  mkdir "$rpm"
  cd "$rpm"
  echo -n " ◔"
  rpm_loc=$(repoquery --repofrompath=$REPOID,$REPOURL --repoid=$REPOID --location "$rpm" 2>/dev/null)
  if $(echo "$rpm_loc" | grep -q -e "^file://") ; then
    rpm_file=$(echo "$rpm_loc" | sed "s=^file://=/=")
  else
    wget --quiet -O "$rpm.rpm" "$rpm_loc"
    rpm_file="$rpm.rpm"
  fi
  echo -ne "\b◑"
  rpmlint_score=$(rpmlint -i "$rpm_file" > "../rpmlint-$rpm.txt" 2>&1 ; echo $?)
  rpm2cpio "$rpm_file" > "$rpm.cpio"
  echo -ne "\b◕"
  cat "$rpm.cpio" | cpio --quiet -it > "$rpm.lst"
  nofont_score=$(cat "$rpm.lst" | sed 's=^\./=/=g' \
    | grep -viE -e "^/usr/share/fonts" \
                -e "^/usr/share/fontconfig/conf.avail/" \
                -e "^/etc/fonts/conf.d/" \
                -e "^/usr/share/doc/" \
                -e "^/etc/X11/fontpath.d/" \
                -e '\.((ttf)|(ttc)|(otf)|(pfa)|(pfb)|(bdf)|(pcf)|(pcf\.gz))$' \
    | wc -l)
  if $(echo $line | cut -d "|" -f 6 | grep -q "E") ; then
    cat "$rpm.lst" \
      | grep -iE '\.((ttf)|(ttc)|(otf)|(pfa)|(pfb)|(bdf)|(pcf)|(pcf\.gz))$' \
      > "$rpm.fonts.lst"
    cpio -idm --quiet -E "$rpm.fonts.lst" < "$rpm.cpio"
  fi
  if $(echo $line | cut -d "|" -f 6 | grep -q "X") ; then
    cat "$rpm.lst" \
      | grep -i -e "^./sbin/" \
                -e "^./usr/sbin/" \
                -e "^./usr/kerberos/sbin" \
                -e "^./bin/" \
                -e "^./usr/bin/" \
                -e "^./usr/kerberos/bin/" \
                -e "^./lib.*/" \
                -e "^./usr/lib.*/" \
                -e "^./opt/" \
                -e "^./usr/X11R6/" \
                -e "^./usr/games/" \
                -e "^./usr/local/" \
      > "$rpm.bin.lst"
    cpio -idm --quiet -E "$rpm.bin.lst" < "$rpm.cpio"
  fi
  echo -ne "\b● "
  [ -r "$rpm.fonts.lst" ] && cat "$rpm.fonts.lst" | sed 's=^\./==g' \
    | while read file; do
    unset target checksum type family style format \
          partial_scripts partial_blocks fontlint
    type=$(file -bzh "$file")
    case $(echo "$type" | sed 's+ (\(.*\)++g' \
                             | sed 's+ `\(.*\)++g' \
                             | sed 's+,\(.*\)++g' \
                             | sed 's+\( \)*$++g' ) in
      "TrueType font data")
        echo -n "t"
        sfnt=true
        ;;
      "TrueType font collection data")
        echo -n "T"
        ;;
      "OpenType font data")
        echo -n "o"
        sfnt=true
        ;;
      "X11 Portable Compiled Font data")
        echo -n "b"
        ;;
      "X11 BDF font text")
        echo -n "B"
        ;;
      # PostScript files are a mess
      "PostScript Type 1 font text")
        echo -n "P"
        ;;
      "PostScript Type 1 font program data")
        echo -n "p"
        ;;
      "PostScript document text conforming DSC level 3.0")
        type="ignored"
        echo -n "-"
        ;;
      "PostScript document text"|"8086 relocatable")
        echo -n "!" >&2
        ;;
      "symbolic link to"|"broken symbolic link to")
        target=$(readlink -m "$file" | sed "s+^$PWD++g")
        if $(echo "$target" | grep -q "^/usr/share/fonts") ; then
          type="Link"
          echo -n "l"
        else
          type="ignored"
          echo -n "-"
        fi
        ;;
      *)
        echo -n "?"
        ;;
    esac
    if [ "$type" != "ignored" ] ; then
      size=$(du -b "$file" | cut -f 1)
      if [ ! -h "$file" ] ; then
        sanfile=$(echo "$file" | sed "s=/=.=g")
        checksum=$(sha256sum "$file" | cut -f 1)
        LANG=C fontlint "$file" 2>&1 | awk 'FNR>3' > \
          "../fontlint-$rpm-$sanfile.txt"
        # Fontlint is too anal and would fail almost every font in the repo if
        # we let it; filter errors so frequent apps must be able to cope with
        # them. Please give feedback if you feel the filtering could be improved
        fontlint=$(cat "../fontlint-$rpm-$sanfile.txt" \
          | awk -F "|" '
              NR==1               { result = $0 }
              NR>1 && $1 !~ /^  / { result = result "\n" $0 }
              NR>1 && $1  ~ /^  / { gsub("^  ", "|",$1)
                                    result = result $0 }
              END { print result }' \
          | awk -F "|" '
              $1 ~ /Validation/ {
                  l=2
                  while (l<NF) {
                    print $l
                    l++
                  }
                  print $NF
                }
              $1 !~ /Validation/ { print }' \
          | awk -F "|" '
              NR==1              { result = $0 }
              NR>1 && $1 !~ /^ / { result = result "\n" $0 }
              NR>1 && $1  ~ /^ / { gsub("^ ", "|",$1)
                                   result = result $0 }
              END { print result }' \
          | grep -v "^The following table(s) in the font have been ignored by FontForge" \
          | grep -v "^The glyph named .* is mapped to .*But its name indicates it should be mapped to .*." \
          | grep -v "^A glyph uses at least one, but not all, anchor classes in a subtable" \
          | grep -v "^This font contains both a .* table and a .* table." \
          | grep -v "^Missing Points at Extrema" \
          | grep -v "^Self Intersecting Glyph" \
          | grep -v "^Wrong Direction" \
          | wc -l)
        if [ "$type" == "TrueType font data" -o \
             "$type" == "OpenType font data" ] ; then
          ttfcoverage "$file" > "../unicover-$rpm-$sanfile.txt"
          # Cut out at 10 like fc-query
          partial_blocks=$(sed \
            's=^\([^\:]*\):\( *\)\([0-9]\+\)/\([0-9]\+\)\( *\)(\([0-9.]\+\)%)$=\1|\3|\4|\6='\
            "../unicover-$rpm-$sanfile.txt" |\
            awk -F '|' '($3-$2 > 0) && ($3-$2 < 10) { print $1 ": " $3-$2 }' | wc -l)
        fi
        fc_file="../fc-query-$rpm-$sanfile.txt"
        if $(FC_DEBUG=256 fc-query "$file" 2> /dev/null > "$fc_file") ; then
          family=$(parse_localized_fc_query family "$fc_file")
          style=$(parse_localized_fc_query style "$fc_file")
          format=$(parse_localized_fc_query fontformat "$fc_file")
          # fc-query only reports partial coverage for 10 glyphs or less,
          # lowering this limit does not significantly reduce the number of
          # flagged fonts today
          partial_scripts=$(grep '^[a-z]\{1,4\}\(-[a-z]\{1,4\}\)\?([1-9]) \+{ \+\([a-f0-9]\{4\} \)\+}' \
                               "$fc_file" | wc -l)
        else
          echo -ne "\b‼" >&2
        fi
      fi
      file="/$file"
      echo "$rpmline|$metadata|$rpmlint_score|$nofont_score|\
$file|$family|$style|$format|$type|$size|$checksum|\
$partial_scripts|$partial_blocks|$fontlint|$target" >> "../$FL.2"
    fi
  done
  [ -r "$rpm.bin.lst" ] && cat "$rpm.bin.lst" | sed 's=^\./==g' \
    | while read file; do
    type=$(file -bzh "$file")
    if $(echo "$type" | grep -q -e '^ELF ' -e ' ELF ') ; then
      if  $(nm -aDu "$file" | grep -q '\<X.*Font') ; then
        echo -n "X"
        size=$(du -b "$file" | cut -f 1)
        checksum=$(sha256sum "$file" | cut -f 1)
        echo "$rpmline|$metadata|$rpmlint_score|$nofont_score|\
$file||||$type|$size|$checksum||||||X" >> "../$FL.2"
      fi
    fi
  done
  cd ..
  rm -fr "$rpm"
  echo " ♻"
done
cd ..
}


consolidate() {
echo "▶▶▶ Consolidating data…"

awk -F "|" '
  $13 != "Link" { source[$9] = $2
                  out[$0] = $0 "|" }
  $13 == "Link" { link[$0] = $9 }
  END {
    for (line in link) { out[line] = line "|" source[link[line]] }
    n = asort(out)
    for (i = 1; i <= n; i++) print out[i]
  }' "tmp/$FL.2" > "$FL"

awk -F "|" '
  $15 != "" { out[$1 "|" $2 "|" $9 "|" $15] = $0 }
  END {
    n = asort(out)
    for (i = 1; i <= n; i++) print out[i]
  }' "$FL" > "$FLNM"

}


analyse() {

echo ""
echo "▶▶▶ Conducting tests…"
echo ""

echo "SRPM|RPM|File" > "$TSUM"


echo -n "— "
test_help outside-usr-share-fonts title }

awk -F '|' '($13 != "Link") && ($21!="X") && \
            ($9 !~ /^\/usr\/share\/fonts\//)' "$FL" > tmp/tmp.csv

list-rpm tmp/tmp.csv
test_wrapup outside-usr-share-fonts tmp/tmp.csv "$TSUM"


echo -n "— "
test_help without-rpm-metadata title

awk -F '|' '($13 != "Link") && ($21!="X") && \
            ($6 != "M")' "$FL" > tmp/tmp.csv

list-rpm tmp/tmp.csv
test_wrapup without-rpm-metadata tmp/tmp.csv "$TSUM"


echo -n "— "
test_help family-mixing title

awk -F '|' '($10 != "")
    {
      rpm = $2 "-" $3 "." $4
      if ( ! family[rpm] ) { family[rpm] = $10 }
      else { if ( family[rpm] != $10 ) { mixed[rpm] = 1 } }
    }
    END {
      for ( rpm in mixed ) { print rpm }
    }' "$FL" | while read rpm ; do
      awk -F '|' -v rpm="$rpm" '(($2 "-" $3 "." $4) == rpm)' "$FL"
    done > tmp/tmp.csv

list-rpm tmp/tmp.csv
test_wrapup family-mixing tmp/tmp.csv "$TSUM"


echo -n "— "
test_help duplicated-file title

awk -F '|' '$21!="X" { print $15 }' "$FLNM" | sort | uniq -d \
  | while read checksum ; do
    awk -F '|' -v checksum="$checksum" '$15==checksum' "$FLNM"
done > tmp/tmp.csv

awk -F '|' '$21!="X" { print $15 }' tmp/tmp.csv | uniq \
  | while read checksum ; do
    awk -F '|' -v checksum="$checksum" '$15==checksum \
        { if ( $6 == "M" ) print $9 "|[" $2 "." $4 "]" ;
          else             print $9 "|"  $2 "." $4  }' \
    tmp/tmp.csv | column -t -s '|' | pretty_indent
  done

test_wrapup duplicated-file tmp/tmp.csv "$TSUM"


echo -n "— "
test_help duplicated-face-ext title

rm -f tmp/tmp.csv
touch tmp/tmp.csv
awk -F '|' '($10 != "") && ($11 != "") \
    { print $2 "-" $3 "." $4 "|" $10 "|" $11 }' "$FLNM" \
    | sort | uniq | awk -F '|' '{ print $2 "|" $3 }' \
    | sort | uniq -d | while read face ; do
    awk -F '|' -v face="$face" '($10 "|" $11)==face' "$FLNM" > tmp/tmp1.csv
    packages=$(awk -F '|' '{ if ( $6 == "M" ) print "[" $2 "]" ; \
                             else print $2 }' tmp/tmp1.csv \
               | sort | uniq | while read rpm ; do echo -n "$rpm " ; done)
    count=$(awk -F '|' '{ print $2 "-" $3 "." $4 }' tmp/tmp1.csv \
            | sort | uniq | wc -l)
    cat tmp/tmp1.csv >> tmp/tmp.csv
    echo "$count|$face|$packages"
  done | sort -nr | column -t -s '|' | pretty_indent

test_wrapup duplicated-face-ext tmp/tmp.csv "$TSUM"


echo -n "— "
test_help fc-query title

awk -F '|' '($13 != "Link") && ($21!="X") && \
            ($12 == "")' "$FL" > tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
awk -F '|' '{ print $2 "-" $3 "." $4 }' tmp/tmp.csv | uniq \
  | while read rpm ; do
    awk -F '|' -v rpm="$rpm" '($2 "-" $3 "." $4) == rpm \
        { sum+=1 ; srpm =$1 } END \
        { print sum "|" rpm "|(" srpm ")|" }' tmp/tmp.csv
  done | sort -nr | column -t -s '|' | pretty_indent

test_wrapup fc-query tmp/tmp.csv "$TSUM"


echo -n "— "
test_help libmagic title

awk -F '|' '($13 != "Link") && ($21!="X") && \
            ($13 !~ /font/) && ($13 !~ /Font/)' "$FL" > tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
awk -F '|' '{ print $2 "-" $3 "." $4 }' tmp/tmp.csv | uniq \
  | while read rpm ; do
    awk -F '|' -v rpm="$rpm" '($2 "-" $3 "." $4) == rpm \
        { sum+=1 ; srpm =$1 } END \
        { print sum "|" rpm "|(" srpm ")|" }' tmp/tmp.csv
  done | sort -nr | column -t -s '|' | pretty_indent

test_wrapup libmagic tmp/tmp.csv "$TSUM"


echo -n "— "
test_help broken-symlink title

awk -F '|' '($13 == "Link") && ($20 == "")' "$FL" > tmp/tmp.csv
awk -F '|' '{ print $9 " → " $19 "|" $2 "-" $3 "." $4  }' tmp/tmp.csv \
  | column -t -s "|" | pretty_indent

test_wrapup broken-symlink tmp/tmp.csv "$TSUM"


echo -n "— "
test_help rpmlint title

awk -F '|' '($13 != "Link") && ($7 != "0")' "$FL" > tmp/tmp.csv

list-rpm tmp/tmp.csv
test_wrapup rpmlint tmp/tmp.csv "$TSUM"


echo -n "— "
test_help mixed-with-non-font-data title

awk -F '|' '($13 != "Link") && ($21!="X") && \
            ($8 != "0")' "$FL" > tmp/tmp.csv

list-rpm tmp/tmp.csv
test_wrapup mixed-with-non-font-data tmp/tmp.csv "$TSUM"


echo -n "— "
test_help arch-package title

awk -F '|' '($13 != "Link") && ($21!="X") && \
            ($4 != "noarch")' "$FL" > tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
awk -F '|' '{ print $2 "." $4 "|" $6 }' tmp/tmp.csv | sort | uniq \
  | awk -F '|' '{ if ( $2 == "M" ) list=(list " [" $1 "]") ;
                              else list=(list " "  $1    ) } END \
                { print list }' | pretty_indent

test_wrapup arch-package tmp/tmp.csv "$TSUM"


echo -n "— "
test_help bad-rpm-naming title

awk -F "|" '($13 != "Link") && ($21!="X") && \
            $2 !~ /^[0-9abcdefghijklmnopqrstuvwxyz\.-]*-fonts$/' "$FL" \
            > tmp/tmp.csv

list-rpm tmp/tmp.csv
test_wrapup bad-rpm-naming tmp/tmp.csv "$TSUM"


echo -n "— "
test_help bad-family-naming title

rm -f tmp/tmp.csv
touch tmp/tmp.csv
awk -F "|" '{ print $10 }' "$FL" | sort | uniq \
  | while read family ; do
    echo -n "$family|"
    echo " $family " | sed "s=[ \t_\.-]\+= =g"
  done > tmp/tmp1.csv
for token in Book Normal Regular Upright ita ital italic cursive \
             kursiv inclined oblique backslanted backslant slanted \
             extra_compressed ext_compressed ultra_compressed \
             ultra_condensed ultra_cond UltraCondensed compressed \
             extra_condensed ext_condensed extra_cond ext_cond \
             ExtraCondensed narrow compact semi_condensed semi_cond \
             SemiCondensed wide semi_expanded semi_extended SemiExpanded \
             extra_expanded ext_expanded extra_extended ext_extended \
             ExtraExpanded ultra_expanded ultra_extended UltraExpanded \
             condensed cond expanded extended extra_thin ext_thin \
             ultra_thin Thin extra_light ext_light ultra_light ExtraLight \
             semi_bold demi_bold DemiBold extra_bold ext_bold ultra_bold \
             ExtraBold extra_black ext_black ultra_black ExtraBlack bold \
             light medium black heavy nord demi ultra ; do
  token=$(echo " $token " | sed 's+_+ +g')
  awk -F "|" -v IGNORECASE=1 -v token="$token" \
  '$2 ~ token { print $1 }' tmp/tmp1.csv
done | sort | uniq | while read family ; do
  awk -F "|" -v family="$family" '$10 == family' "$FL" >> tmp/tmp.csv
done

awk -F "|" '{ print $10 }' tmp/tmp.csv | sort | uniq \
  | while read family ; do
    rpmlist=$(awk -F "|" -v family="$family" '$10 == family \
      { if ( $6 == "M" ) print "[" $2 "]" ; \
                    else print     $2     }' tmp/tmp.csv \
      | sort | uniq | while read rpm ; do echo -n "$rpm " ; done)
    echo "$family|$rpmlist"
  done | column -t -s '|' | pretty_indent

test_wrapup bad-family-naming tmp/tmp.csv "$TSUM"


echo -n "— "
test_help bad-style-naming title
echo -n "   "

#FIXME It would also be great to check if the naming is corrected by the
#      fontconfig files shipped in the package, but this requires fixes in
#      fc-scan (ability to process non-deployed fontconfig files)
rm -f tmp/tmp.csv
touch tmp/tmp.csv
awk -F "|" '{ print $11 }' "$FL" | sort | uniq \
  | while read face ; do
    echo -ne "\b○"
    rface=$(wws_resolve "$face" "Book Normal Regular Roman Upright")
    echo -ne "\b◔"
    rface=$(wws_resolve "$rface" "ita ital italic cursive kursiv inclined \
                                  oblique backslanted backslant slanted")
    echo -ne "\b◑"
    rface=$(wws_resolve "$rface" "extra_compressed ext_compressed \
                                  ultra_compressed ultra_condensed \
                                  ultra_cond UltraCondensed compressed \
                                  extra_condensed ext_condensed extra_cond \
                                  ext_cond ExtraCondensed narrow compact \
                                  semi_condensed semi_cond SemiCondensed \
                                  wide semi_expanded semi_extended \
                                  SemiExpanded extra_expanded ext_expanded \
                                  extra_extended ext_extended ExtraExpanded \
                                  ultra_expanded ultra_extended \
                                  UltraExpanded condensed cond expanded \
                                  extended")
    echo -ne "\b◕"
    rface=$(wws_resolve "$rface" "extra_thin ext_thin ultra_thin Thin \
                                  extra_light ext_light ultra_light \
                                  ExtraLight semi_bold demi_bold DemiBold \
                                  extra_bold ext_bold ultra_bold ExtraBold \
                                  extra_black ext_black ultra_black \
                                  ExtraBlack bold light medium black heavy \
                                  nord demi ultra")
    if [ "$rface" != "" ] ; then
      awk -F "|" -v face="$face" '$11 == face' "$FL" >> tmp/tmp.csv
      echo -ne "\bx "
    else echo -ne "\b●"
    fi
  done
echo ""

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
awk -F "|" '{ print $10 ", " $11 }' tmp/tmp.csv | sort | uniq \
  | while read fontface ; do
    awk -F "|" -v fontface="$fontface" '($10 ", " $11) == fontface \
      { if ( $6 == "M" ) print fontface "|" $9 "|[" $2 "]" ; \
                    else print fontface "|" $9 "|"  $2     }' tmp/tmp.csv \
      | sort | uniq
  done | column -t -s '|' | pretty_indent

test_wrapup bad-style-naming tmp/tmp.csv "$TSUM"


echo -n "— "
test_help core-fonts title

awk -F '|' '$21=="X"' "$FLNM" > tmp/tmp.csv

list-rpm tmp/tmp.csv
test_wrapup core-fonts tmp/tmp.csv "$TSUM"


echo -n "— "
test_help font-linking title

awk -F '|' '$13=="Link"' "$FL" > tmp/tmp.csv

list-rpm tmp/tmp.csv
test_wrapup font-linking tmp/tmp.csv "$TSUM"


echo -n "— "
test_help duplicated-face-int title

awk -F '|' '($10 != "") && ($11 != "") && ($12 != "PCF") && ($12 != "Type 1") \
    { print $2 "-" $3 "." $4 "|" $10 "|" $11 }' "$FLNM" \
  | sort | uniq -d | while read sig ; do
    awk -F '|' -v sig="$sig" \
        '($12 != "PCF") && ($12 != "Type 1") && \
         (($2 "-" $3 "." $4 "|" $10 "|" $11 ) == sig)' \
         "$FLNM" ;
    done > tmp/tmp.csv

awk -F '|' '{ print $2 "|" $10 "|" $11 "|" $9 }' tmp/tmp.csv \
  | column -t -s '|' | pretty_indent

test_wrapup duplicated-face-int tmp/tmp.csv "$TSUM"


echo -n "— "
test_help fontlint title

awk -F '|' '($18 > 0)' "$FL" > tmp/tmp.csv

list-rpm tmp/tmp.csv
test_wrapup fontlint tmp/tmp.csv "$TSUM"


echo -n "— "
test_help no-english-metadata title

awk -F '|' '($12 != "") && (($10 == "") || ($11 == ""))' "$FL" > tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
awk -F '|' '{ print $9 "|" $2 "-" $3 "." $4 }' tmp/tmp.csv \
  | column -t -s '|' | pretty_indent

test_wrapup no-english-metadata tmp/tmp.csv "$TSUM"


echo -n "— "
test_help partial-scripts title

awk -F '|' '($16 > 0)' "$FL" > tmp/tmp.csv

list-rpm tmp/tmp.csv
test_wrapup partial-scripts tmp/tmp.csv "$TSUM"


echo -n "— "
test_help partial-blocks title

awk -F '|' '($17 > 0)' "$FL" > tmp/tmp.csv

list-rpm tmp/tmp.csv
test_wrapup partial-blocks tmp/tmp.csv "$TSUM"
}


sum_up() {
echo ""
echo "▶▶▶ Audit results:"
echo ""

echo "– packages that declare font metadata:"
echo ""

awk -F '|' '$6=="M"' "$FL" > tmp/tmp.csv
stats tmp/tmp.csv

echo "☛ File size is computed as extracted, while rpm is a compressed \
format." | pretty_indent
echo "☛ Mid-term, files in legacy PCF or Type1 formats need to be converted \
or removed." | pretty_indent

echo "– font files in other packages (we should not find any!)"
echo ""

awk -F '|' '($6 != "M") && ($13 != "Link")' "$FL" > tmp/tmp.csv
stats tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
echo "☛ Bad packaging may result in arched packages or mixed content." \
| pretty_indent

echo "– errors, warnings and suggestions:"
echo ""

test_score "$TSUM"

}


prepare_spam() {
mkdir spam

for srpm in $(awk -F '|' 'FNR>1 { print $1 }' "$TSUM" | uniq) ; do
  mkdir "tmp/$srpm/"
  cp -p report.txt "tmp/$srpm/repo-report.txt"
  for file in "$FL" "$TSUM" ; do
    awk 'FNR==1' "$file" > "tmp/$srpm/$file"
    awk -F '|' -v srpm="$srpm" 'FNR>1 && $1==srpm' "$file" >> "tmp/$srpm/$file"
  done
  for rpm in $(awk -F '|' 'FNR>1 { print $2 }' "tmp/$srpm/$TSUM" | uniq) ; do
    cp -p tmp/rpmlint-$rpm-*.txt "tmp/$srpm/"
    cp -p tmp/fc-query-$rpm-*.txt \
          tmp/unicover-$rpm-*.txt \
          tmp/fontlint-$rpm-*.txt "tmp/$srpm/" 2>/dev/null
  done
  cat > tmp/$srpm/message.txt << EOF
Dear packager,

At $TIMESTAMP, your “$srpm” package failed one or more of the tests
I was performing on the “$ID” repository located at:
$REPOURL

There are three different reasons that may cause this message:
1. your package is including one or more font files, but not packaging
   them properly;
2. your package is including one or more font files, and I've found
   issues in some of them;
3. your package is not shipping any font file, but the way it accesses
   fonts in other packages is not satisfying.

To stop receiving this message, you need to:
1. drop the font files or fix their packaging;
2. relay the fonts issues to the fonts upstream to get them revised;
3. work with the code upstream to improve the way it accesses font
   files (usually by making it use fontconfig through a higher-level
   text library such as pango, pango-cairo, harfbuzz, or QT)

You can self-check your packages at any time by:
1. installing createrepo and fontpackages-tools:
# yum install createrepo fontpackages-tools
2. putting your packages and any font package they depends on in a
   test directory
3. indexing this directory with createrepo:
$ createrepo path-to-test-directory
4. running repo-font-audit:
$ repo-font-audit test file://absolute-path-to-test-directory

A summary of the issues I detected is appended here. For your
convenience a more comprehensive analysis is also attached to this
message.

Errors, warnings and suggestions:

$(test_score "tmp/$srpm/$TSUM")



Please take the appropriate measures to fix the “$srpm” package.
I will warn you again if it is still necessary next time I am ran.

This report was generated by the repo-font-audit command from:
http://fedoraproject.org/wiki/fontpackages

Please post questions, suggestions, patches or bug reports to:
https://www.redhat.com/mailman/listinfo/fedora-fonts-list
(subscription required)

Your friendly QA robot,

-- 
repo-font-audit
EOF
  cd tmp
  tar cf "$srpm.tar" "$srpm"
  cd ..
  xz -9  "tmp/$srpm.tar"
  mv "tmp/$srpm.tar.xz" spam
done
cat > spam/send-messages.sh << EOF
#!/bin/sh
# Send warnings to problem package owners
# This is a bit distribution-specific, people from other distributions are
# welcome to suggest how to make it more agnostic

#EMAIL="repo-font-audit <your@mail>"
#REPLYTO=another@mail

#export EMAIL REPLYTO

for srpm in \\
$(awk -F '|' 'FNR>1 { print $1 " \\" }' "$TSUM" | uniq)
; do
  tar -xf \$srpm.tar.xz */message.txt -O \\
    | mutt -s "[RFA] Your \$srpm $ID package did not pass QA!" \\
           -a \$srpm.tar.xz -- \$srpm-owner@fedoraproject.org
  sleep 5
done

EOF
chmod +x spam/send-messages.sh
}

pack_data() {
mv spam "$SPAM"

mkdir "$RES/"
cp "$FL" "$TSUM" \
   tmp/rpmlint-*.txt tmp/fc-query-*.txt tmp/unicover-*.txt tmp/fontlint-*.txt \
   summary.txt report.txt "$RES/"

mkdir "$SRES/"
cp "$TSUM" summary.txt report.txt "$SRES/"

for report in "$RES" "$SRES" "$SPAM" ; do
  tar cf "$report.tar" "$report"
  xz -9  "$report.tar"
  mv "$report.tar.xz" "$ORIGDIR/"
done

cat << EOF

▶▶▶ Audit complete! Number of items processed:
$(summary "$FL")

1. Extracted data: $ORIGDIR/$RES.tar.xz
2. Short summary: $ORIGDIR/$SRES.tar.xz
3. Mail data: $ORIGDIR/$SPAM.tar.xz


This report was generated by the repo-font-audit command from:
http://fedoraproject.org/wiki/fontpackages

Please post questions, suggestions, patches or bug reports to:
https://www.redhat.com/mailman/listinfo/fedora-fonts-list
(subscription required)
EOF
}

# End of function declarations

[ "$#" -lt "2" ] && usage

TIMESTAMP=$(date -u +%Y%m%dT%H%M%SZ)
ID=$1
REPOID="$1-rfa-$TIMESTAMP"
REPOURL=$2
ORIGDIR="$PWD"

FPL="font-packages.csv"
PWFL="packages-with-fonts.csv"
XPL="package-using-x11.csv"
CSL="checksums.csv"
FL="consolidated-data.csv"
FLNM="consolidated-data-no-multilib.csv"
TSUM="test-summary.csv"
RES="repo-font-audit-$ID-$TIMESTAMP"
SRES="repo-font-audit-$ID-$TIMESTAMP-short"
SPAM="repo-font-audit-$ID-$TIMESTAMP-mail"

TMPDIR=$(mktemp -d --tmpdir=/tmp $RES-XXXXXXXXXX)
cd $TMPDIR

mkdir tmp

collect
consolidate
analyse | tee report.txt
sum_up  | tee summary.txt

sed -i "s=.$(echo -ne '\b')==g" report.txt

cp "$FL" "tmp/$FL"
echo "SRPM|RPM|EVR|Arch|RPM size|RPM metadata|rpmlint score|foreign data|\
filename|family name|face name|format (fontconfig)|format (libmagic)|\
file size|checksum|partial scripts|partial blocks|fontlint|symlink target|\
symlink provider|core fonts use" > "$FL"
cat "tmp/$FL" >> "$FL"

prepare_spam
pack_data

cd "$ORIGDIR"
rm -fr "$TMPDIR"
echo "♻"
