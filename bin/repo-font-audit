#!/bin/bash
# Quick and dirty script to audit font repartition in a yum package repository
#
# It is slow, it is ugly, and it requires a good network connection

# Function declarations

usage() {
/bin/cat >&2 << EOF_USAGE
Usage: $0 ID URL1

With:
— ID:   identifier of the package repository to test
— URL1: url of the package repository to test

EOF_USAGE
exit 1
}



# FIXME: only extracts info about the first typeface in a TTC file for now
parse_localized_fc_query() {
  field="$1"
  file="$2"
  fieldstring=$(awk -F ':' -v field="$field"  '$1 == "\t"field { print $2 ; exit }' "$file" \
               | sed 's="(s)="=g' | sed 's=" *"=|=g'| sed 's= *" *==g')"|"
  default=$(echo $fieldstring | awk -F "|" '{ print $1 }')
  if $(grep -q "^"$'\t'$field"lang:" "$file") ; then
    langstring=$(awk -F ':' -v field="$field" \
                '$1 == "\t"field"lang" { print $2 ; exit }' "$file" \
                | sed 's="(s)="=g' | sed 's=" *"=|=g'| sed 's= *" *==g')"|"
    # Try to find the English label
    while [ "$langstring" != "" -a \
            "$(echo $langstring | awk -F '|' '{ print $1 }')" != "en" ] ; do
      fieldstring=$(echo "$fieldstring" | sed 's+\([^|]*\)|\(.*\)+\2+g')
      langstring=$(echo "$langstring" | sed 's+\([^|]*\)|\(.*\)+\2+g')
    done
    # We could hide problems by reporting the first label regardless of its
    # language. But this is an audit script — we do not hide problems
    echo "$fieldstring" |  awk -F "|" '{ print $1 }'
    if [ "$fieldstring" == "" ] ; then  echo -ne "\b×" >&2 ; fi
  else
    echo $(echo $fieldstring | awk -F "|" '{ print $1 }')
  fi
}


pretty_indent() {
  fold -s -w $(($(tput cols) - 4)) \
  | while read line ; do echo "    $line" ; done
  echo ""
}

tally() {
t_datafile=$1

t_file=$(cat "$t_datafile" | wc -l)
t_file_size=$(awk -F '|' '{ sum += $14 } END { print sum }' "$t_datafile")
t_file_size=$((t_file_size/(1024*1024)))

t_rpm=$(awk -F '|' '{ print $2 "-" $3 "." $4 }' "$t_datafile" | sort | uniq | wc -l)
t_rpm_size=$(awk -F '|' '{ print $2 "-" $3 "." $4 "|" $5 }' "$t_datafile" | sort | uniq \
            |awk -F '|' '{ sum += $2 } END { print sum }')
t_rpm_size=$((t_rpm_size/(1024*1024)))

t_srpm=$(awk -F '|' '{ print $1 }' "$t_datafile" | sort | uniq | wc -l)

echo "$t_file|$t_rpm|$t_srpm|$t_file_size|$t_rpm_size"
}

summary() {

if [ $(cat "$1" | wc -l) -gt 0 ] ; then
  tally "$1" | awk -F '|' '{ print "⇒ " $1 " files (" $4 " MiB) in " $2 \
        " packages (" $5 " MiB) generated from " $3 " source packages." }' \
        | pretty_indent
else
  echo "⇒  None!" | pretty_indent
fi
}

substats() {
ss_datafile="$1"

awk -F '|' '{ print $NF }' "$ss_datafile" | sort | uniq \
  | while read key ; do
    echo -n "$key|"
    awk -F '|' -v key="$key" '$NF==key' "$ss_datafile" > tmp.ss.csv
    tally tmp.ss.csv
    rm tmp.ss.csv
  done
}

stats() {
s_datafile="$1"

summary "$s_datafile"

if [ $(cat "$s_datafile" | wc -l) -gt 0 ] ; then
  (echo "Format|Files|rpm|srpm|Files (MiB)|rpm (MiB)"
  awk -F '|' '$12 != "" { print $0 "|" $12 }' "$s_datafile" > tmp.s.csv
  substats tmp.s.csv) | column -t -s '|' | pretty_indent

  (echo "Format|Files|rpm|srpm|Files (MiB)|rpm (MiB)"
  awk -F '|' '{ print $0 "|" $4 }' "$s_datafile" > tmp.s.csv
  substats tmp.s.csv)| column -t -s '|' | pretty_indent

  rm tmp.s.csv
fi
}

list-rpm() {

if [ $(cat "$1" | wc -l) -gt 0 ] ; then
  awk -F '|' '{ if ( $6 == "M" ) print "[" $2 "]" ; \
                            else print     $2     }' "$1" | sort | uniq \
    | awk -F '|' '{ list = list " " $1 } END { print list }' | pretty_indent
fi
}

canonalise_and_invert_string() {
  cais=""
  for token in $(echo "$@" | sed "s=[ \t_\.-]\+= =g" | sed "s=^ ==g" \
                           | sed "s= $==g") ; do
      cais="$token $cais"
  done
  echo " $cais"
}

wws_resolve () {
cais_name=$(canonalise_and_invert_string $1)
result="$cais_name"
patterns=""
for pattern in $2 ; do patterns="$pattern $patterns" ; done
for pattern in $patterns ; do
   pattern=$(canonalise_and_invert_string $pattern)
   tmp=$(echo "$cais_name" | sed "s=$pattern= =i")
   [ "$tmp" != "$cais_name" ] && result="$tmp"
done
result=$(canonalise_and_invert_string "$result" \
         | sed "s=^ ==" | sed "s= $==")
echo "$result"
}

collect() {
echo "Searching for packages with font metadata…"
repoquery --repofrompath=$REPOID,$REPOURL --repoid=$REPOID \
          --qf "%{sourcerpm}|%{name}|%{epoch}:%{version}-%{release}|%{arch}|%{packagesize}" \
          --whatprovides "font(*)" 2>/dev/null | sort | uniq \
          > "$FPL"

echo "Searching for packages that include files with common font extensions…"
repoquery --repofrompath=$REPOID,$REPOURL --repoid=$REPOID \
          --qf "%{sourcerpm}|%{name}|%{epoch}:%{version}-%{release}|%{arch}|%{packagesize}" \
          -f '*.ttf' -f '*.otf' -f '*.ttc' \
          -f '*.pfb' -f '*.pfa' -f '*.pcf.gz' 2>/dev/null | sort | uniq \
          > "$PWFL"

echo "Inspecting packages:"
rm -f "$FFL"
cd "tmp"
cat ../$FPL ../$PWFL | awk -F '|' '{ print $2 "-" $3 "." $4 }' | sort | uniq \
  | while read rpm ; do
  echo -n " – $rpm"
  mkdir "$rpm"
  cd "$rpm"
  echo -n " ◔"
  rpm_loc=$(repoquery --repofrompath=$REPOID,$REPOURL --repoid=$REPOID --location "$rpm" 2>/dev/null)
  if $(echo "$rpm_loc" | grep -q -e "^file://") ; then
    rpm_file=$(echo "$rpm_loc" | sed "s=^file://=/=")
  else
    wget --quiet -O "$rpm.rpm" "$rpm_loc"
    rpm_file="$rpm.rpm"
  fi
  echo -ne "\b◑"
  rpmlint_score=$(rpmlint "$rpm_file" > "../rpmlint-$rpm.txt" 2>&1 ; echo $?)
  rpm2cpio "$rpm_file" > "$rpm.cpio"
  echo -ne "\b◕"
  cpio --quiet -it < "$rpm.cpio" > "$rpm.lst"
  nofont_score=$(cat "$rpm.lst" \
    | grep -v "^./usr/share/fonts" \
    | grep -v "^./usr/share/fontconfig/conf.avail/" \
    | grep -v "^./etc/fonts/conf.d/" \
    | grep -v "^./usr/share/doc/" \
    | grep -v "^./etc/X11/fontpath.d/" \
    | grep -viE '\.((ttf)|(ttc)|(otf)|(pfa)|(pfb)|(pcf)|(pcf\.gz))$' |wc -l)
  cat "$rpm.lst" \
    | grep -iE '\.((ttf)|(ttc)|(otf)|(pfa)|(pfb)|(pcf)|(pcf\.gz))$' \
    > "$rpm.fonts.lst"
  cpio -idm --quiet -E "$rpm.fonts.lst" < "$rpm.cpio"
  echo -ne "\b● "
  cat "$rpm.fonts.lst" | while read file; do
    unset target checksum type family style format
    type=$(file -bzh "$file")
    case $(echo "$type" | sed 's+ (\(.*\)++g' \
                             | sed 's+ `\(.*\)++g' \
                             | sed 's+,\(.*\)++g' \
                             | sed 's+\( \)*$++g' ) in
      "TrueType font data")
        echo -n "t"
        ;;
      "TrueType font collection data")
        echo -n "T"
        ;;
      "OpenType font data")
        echo -n "o"
        ;;
      "X11 Portable Compiled Font data")
        echo -n "b"
        ;;
      # PostScript files are a mess
      "PostScript Type 1 font text")
        echo -n "P"
        ;;
      "PostScript Type 1 font program data")
        echo -n "p"
        ;;
      "PostScript document text conforming DSC level 3.0")
        type="ignored"
        echo -n "-"
        ;;
      "PostScript document text"|"8086 relocatable")
        echo -n "x" >&2
        ;;
      "symbolic link to"|"broken symbolic link to")
        target=$(readlink -m "$file" | sed "s+^$PWD++g")
        if $(echo "$target" | grep -q "^/usr/share/fonts") ; then
          type="Link"
          echo -n "l"
        else
          type="ignored"
          echo -n "-"
        fi
        ;;
      *)
        echo -n "?"
        ;;
    esac
    if [ "$type" != "ignored" ] ; then
      size=$(du -b "$file" | awk '{ print $1 ; exit }')
      if [ ! -h "$file" ] ; then
        checksum=$(sha256sum "$file" | awk '{ print $1 ; exit }')
        if $(fc-query "$file" 2> /dev/null > "$file.desc") ; then
          family=$(parse_localized_fc_query family "$file.desc")
          style=$(parse_localized_fc_query style "$file.desc")
          format=$(parse_localized_fc_query fontformat "$file.desc")
        else
          echo -ne "\bX" >&2
        fi
      fi
      file=$(echo "$file" | sed "s+^./+/+g")
      echo "$rpm|$rpmlint_score|$nofont_score\
|$file|$family|$style|$format|$type|$size|$checksum|$target" >> "../../$FFL"
    fi
  done
  cd ..
  rm -fr "$rpm"
  echo " ♻"
done
cd ..
}

consolidate() {
echo "Consolidating data…"

rm -f "$FL"
cat "$PWFL" | while read rpmline; do
  grep -q "$rpmline" "$FPL" && metadata="M" || metadata=""
  rpm=$(echo "$rpmline" | awk -F '|' '{ print $2 "-" $3 "." $4 ; exit }')
  awk -F '|' -v rpm="$rpm" '$1 == rpm' "$FFL" \
  | while read rawfileline ; do
    echo "$rawfileline" | \
      awk -F "|" '{ for (i = 2; i < NF; i++) list = list $i "|" } END { print list $NF }' \
      | while read fileline ; do
      if [ "$(echo $fileline| awk -F '|' '{ print $7 }')" == "Link" ] ; then
        source="$(awk -F '|' -v target=""$(echo $fileline| awk -F '|' '{ print $10 }')"" \
                   '$4 == target { print $1 ; exit }' ""$FFL"" )"
      else source=""
      fi
     echo "$rpmline|$metadata|$fileline|$source" >> "$FL"
     done
  done
done


awk -F '|' '$15 != "" { print $1 "|" $2 "|" $9 "|" $15 }' "$FL" | sort | uniq \
  | while read sig ; do
    awk -F '|' -v sig="$sig" \
        '($1 "|" $2 "|" $9 "|" $15) == sig { print $0 ; exit }' "$FL"
  done > "$FLNM"
}

analyse() {
echo ""
echo "Statistics:"
echo ""

echo "– packages that declare font metadata:"
echo ""

awk -F '|' '$6=="M"' "$FL" > tmp/tmp.csv
stats tmp/tmp.csv

echo "☛ File size is computed as extracted, while rpm is a compressed \
format." | pretty_indent
echo "☛ Mid-term, files in legacy PCF or Type1 formats need to be converted \
or removed." | pretty_indent

echo "– font files in other packages (we should not find any!)"
echo ""

awk -F '|' '($6 != "M") && ($13 != "Link")' "$FL" > tmp/tmp.csv
stats tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
echo "☛ Bad packaging may result in arched packages or mixed content." \
| pretty_indent

echo ""
echo "Problem report:"
echo ""

# Arch check

echo "– font files in arch packages:"

awk -F '|' '($13 != "Link") && ($4 != "noarch")' "$FL" > tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
awk -F '|' '{ print $2 "." $4 "|" $6 }' tmp/tmp.csv | sort | uniq \
  | awk -F '|' '{ if ( $2 == "M" ) list=(list " [" $1 "]") ;
                              else list=(list " "  $1    ) } END \
                { print list }' | pretty_indent

summary tmp/tmp.csv

# Install location check

echo "– font files installed outside /usr/share/fonts:"

awk -F '|' '($13 != "Link") && ($9 !~ /^\/usr\/share\/fonts\//)' "$FL" > tmp/tmp.csv

list-rpm tmp/tmp.csv

summary tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
echo "☛ Font files need to be installed under the /usr/share/fonts root for \
fontconfig to expose them." | pretty_indent

# Mixed contents check

echo "— fonts in packages that contain non-font data:"

awk -F '|' '($13 != "Link") && ($8 != "0")' "$FL" > tmp/tmp.csv

list-rpm tmp/tmp.csv

summary tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
echo "☛ Every font should be installable as-is without pulling in other \
material." | pretty_indent

# Metadata check

echo "– fonts in packages that do not declare font metadata:"

awk -F '|' '($13 != "Link") && ($6 != "M")' "$FL" > tmp/tmp.csv

list-rpm tmp/tmp.csv

summary tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
echo "☛ Automatic font installation relies on this metadata being present \
to work." | pretty_indent

# Naming checks

echo "– fonts in packages that do not use font package naming conventions:"

awk -F "|" '$2 !~ /^[0-9abcdefghijklmnopqrstuvwxyz\.-]*-fonts$/' "$FL" > tmp/tmp.csv

list-rpm tmp/tmp.csv

summary tmp/tmp.csv

echo -n "— fonts that declare face attributes in family names:  "

#FIXME This test could probably be rewritten to be much faster
rm -f tmp/tmp.csv
touch tmp/tmp.csv
awk -F "|" '{ print $10 }' "$FL" | sort | uniq \
  | while read family ; do
    echo -ne "\b?"
    rfamily=$(echo "$family" | sed "s=[ \t_\.-]\+= =g" | sed "s=^= =g" \
                             | sed "s=$= =g")
    badnaming=0
    for token in Book Normal Regular Upright ita ital italic cursive \
                 kursiv inclined oblique backslanted backslant slanted \
                 extra_compressed ext_compressed ultra_compressed \
                 ultra_condensed ultra_cond UltraCondensed compressed \
                 extra_condensed ext_condensed extra_cond ext_cond \
                 ExtraCondensed narrow compact semi_condensed semi_cond \
                 SemiCondensed wide semi_expanded semi_extended SemiExpanded \
                 extra_expanded ext_expanded extra_extended ext_extended \
                 ExtraExpanded ultra_expanded ultra_extended UltraExpanded \
                 condensed cond expanded extended extra_thin ext_thin \
                 ultra_thin Thin extra_light ext_light ultra_light ExtraLight \
                 semi_bold demi_bold DemiBold extra_bold ext_bold ultra_bold \
                 ExtraBold extra_black ext_black ultra_black ExtraBlack bold \
                 light medium black heavy nord demi ultra ; do
      token=$(echo "$token" | sed "s+_+ +g")
      $(echo "$rfamily" | grep -q -e " $token ") && badnaming=$((badnaming+1))
    done
    if [ $badnaming -gt 0 ] ; then
      awk -F "|" -v family="$family" '$10 == family' "$FL" >> tmp/tmp.csv
      echo -ne "\bx "
    else
      echo -ne "\b-"
    fi
  done
echo ""

awk -F "|" '{ print $10 }' tmp/tmp.csv | sort | uniq \
  | while read family ; do
    rpmlist=$(awk -F "|" -v family="$family" '$10 == family \
      { if ( $6 == "M" ) print "[" $2 "]" ; \
                    else print     $2     }' tmp/tmp.csv \
      | sort | uniq | while read rpm ; do echo -n "$rpm " ; done)
    echo "$family|$rpmlist"
  done | column -t -s '|' | pretty_indent

summary tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
echo -e "☛ To be properly processed by applications face qualifiers need to \
be declared in face names (there may be a few false positives here as some \
common face qualifiers can be used with a different meaning in family names; \
if that's not the case, please ask the font upstream to fix its naming)." \
| pretty_indent

echo -n "— fonts that declare non-WWS compliant faces:  "

#FIXME It would also be great to check if the naming is corrected by the
#      fontconfig files shipped in the package, but this requires fixes in
#      fc-scan (ability to process non-deployed fontconfig files)
rm -f tmp/tmp.csv
touch tmp/tmp.csv
awk -F "|" '{ print $11 }' "$FL" | sort | uniq \
  | while read face ; do
    echo -ne "\b○"
    rface=$(wws_resolve "$face" "Book Normal Regular Roman Upright")
    echo -ne "\b◔"
    rface=$(wws_resolve "$rface" "ita ital italic cursive kursiv inclined \
                                  oblique backslanted backslant slanted")
    echo -ne "\b◑"
    rface=$(wws_resolve "$rface" "extra_compressed ext_compressed \
                                  ultra_compressed ultra_condensed \
                                  ultra_cond UltraCondensed compressed \
                                  extra_condensed ext_condensed extra_cond \
                                  ext_cond ExtraCondensed narrow compact \
                                  semi_condensed semi_cond SemiCondensed \
                                  wide semi_expanded semi_extended \
                                  SemiExpanded extra_expanded ext_expanded \
                                  extra_extended ext_extended ExtraExpanded \
                                  ultra_expanded ultra_extended \
                                  UltraExpanded condensed cond expanded \
                                  extended")
    echo -ne "\b◕"
    rface=$(wws_resolve "$rface" "extra_thin ext_thin ultra_thin Thin \
                                  extra_light ext_light ultra_light \
                                  ExtraLight semi_bold demi_bold DemiBold \
                                  extra_bold ext_bold ultra_bold ExtraBold \
                                  extra_black ext_black ultra_black \
                                  ExtraBlack bold light medium black heavy \
                                  nord demi ultra")
    if [ "$rface" != "" ] ; then
      awk -F "|" -v face="$face" '$11 == face' "$FL" >> tmp/tmp.csv
      echo -ne "\bx "
    else echo -ne "\b●"
    fi
  done
echo ""

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
awk -F "|" '{ print $10 ", " $11 }' tmp/tmp.csv | sort | uniq \
  | while read fontface ; do
    awk -F "|" -v fontface="$fontface" '($10 ", " $11) == fontface \
      { if ( $6 == "M" ) print fontface "|" $9 "|[" $2 "]" ; \
                    else print fontface "|" $9 "|"  $2     }' tmp/tmp.csv \
      | sort | uniq
  done | column -t -s '|' | pretty_indent

summary tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
echo -e "☛ This WWS-like test checks if font faces use the: \n\
“width weight slant” \n\
naming convention. \n\
http://blogs.msdn.com/text/attachment/2249036.ashx \n\
(Microsoft resolves over a combined “Family Face” string, since our \
applications use “Family” and “Face” separately this test considers “Face” \
alone. We also reject weight abbreviations and suffixes, if a font uses them \
check compliance manually.) \n\
If your font is listed here please ask its upstream to fix its naming, and in \
the meanwhile add a fontconfig rule to your package to hide the breakage (see \
the remapping template)." | pretty_indent

# Duplication checks

echo "– exact file duplication (ignoring multilib):"
echo "☛ Ignoring multilib to keep it short" | pretty_indent

awk -F '|' '{ print $15 }' "$FLNM" | sort | uniq -d \
  | while read checksum ; do
    awk -F '|' -v checksum="$checksum" '$15==checksum' "$FLNM"
done > tmp/tmp.csv

awk -F '|' '{ print $15 }' tmp/tmp.csv | uniq \
  | while read checksum ; do
    awk -F '|' -v checksum="$checksum" '$15==checksum \
        { if ( $6 == "M" ) print $9 "|[" $2 "." $4 "]" ;
          else             print $9 "|"  $2 "." $4  }' \
    tmp/tmp.csv | column -t -s '|' | pretty_indent
  done

summary tmp/tmp.csv

echo "– font faces duplicated by different packages:"
echo "☛ Excluding multilib and PCF fonts (because they are pretty much \
hopeless)." | pretty_indent

rm -f tmp/tmp.csv
touch tmp/tmp.csv
awk -F '|' '($10 != "") && ($11 != "") && ($12 != "PCF") && ($12 != "Type 1") \
    { print $2 "-" $3 "." $4 "|" $10 "|" $11 }' "$FLNM" \
    | sort | uniq | awk -F '|' '{ print $2 "|" $3 }' \
    | sort | uniq -d | while read face ; do
    awk -F '|' -v face="$face" \
        '($12 != "PCF") && (($10 "|" $11)==face)' "$FLNM" > tmp/tmp1.csv
    packages=$(awk -F '|' '{ if ( $6 == "M" ) print "[" $2 "]" ; \
                             else print $2 }' tmp/tmp1.csv \
               | sort | uniq | while read rpm ; do echo -n "$rpm " ; done)
    count=$(awk -F '|' '{ print $2 "-" $3 "." $4 }' tmp/tmp1.csv \
            | sort | uniq | wc -l)
    cat tmp/tmp1.csv >> tmp/tmp.csv
    echo "$count|$face|$packages"
  done | sort -nr | column -t -s '|' | pretty_indent

summary tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
echo "☛ Face duplication wastes resources \
infrastructure and user side. Very often an upstream that copied some fonts \
will forget to keep them up to date, and the duplication will result in the \
distribution of old buggy data. Even if some duplicate font files are a \
genuine fork with different features from the original, applications won't be \
able to select them relyably because of naming collisions. We should alway \
ship a single version of any font face in a dedicated font package, and use \
fontconfig or symlinks to share it accross packages." | pretty_indent

echo "– font faces duplicated within a package (ignoring legacy formats):"

awk -F '|' '($10 != "") && ($11 != "") && ($12 != "PCF") && ($12 != "Type 1") \
    { print $2 "-" $3 "." $4 "|" $10 "|" $11 }' "$FLNM" \
  | sort | uniq -d | while read sig ; do
    awk -F '|' -v sig="$sig" \
        '($12 != "PCF") && ($12 != "Type 1") && \
         (($2 "-" $3 "." $4 "|" $10 "|" $11 ) == sig)' \
         "$FLNM" ;
    done > tmp/tmp.csv

awk -F '|' '{ print $2 "|" $10 "|" $11 "|" $9 }' tmp/tmp.csv \
  | column -t -s '|' | pretty_indent

summary tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
echo "☛ Face duplication within a package is almost certainly a bug, except \
for special symbol font families." | pretty_indent

# Bad mixing checks

echo "— packages that mix several font families (ignoring legacy formats):"

awk -F '|' '($10 != "") && ($12 != "PCF") && ($12 != "Type 1")' "$FL" > tmp/tmp.csv
awk -F '|' '{ print $2 "-" $3 "." $4 }' tmp/tmp.csv | sort | uniq \
  | while read rpm ; do
    awk -F '|' -v rpm="$rpm" '(($2 "-" $3 "." $4) == rpm) \
          { print $2 "|" $10 }' tmp/tmp.csv | sort | uniq \
      | awk -F '|' '{ sum+=1 ; rpm=$1 } END { if (sum > 1) print sum " " rpm  }'
  done | sort -nr | awk '{ list = list " " $2 " (" $1 ")" } END \
                         { print list }' | pretty_indent

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
echo "☛ Reliable font autoinstallation requires shipping only one font family \
per font package. This indicates problems in the packaging or the packaged \
font metadata." | pretty_indent

# Symlink-related checks

echo "– packages that symlink font files:"

awk -F '|' '$13=="Link"' "$FL" > tmp/tmp.csv

list-rpm tmp/tmp.csv

summary tmp/tmp.csv

if [ $(cat tmp/tmp.csv | wc -l) -gt 0 ] ; then
echo "    5 most symlinked packages:"
awk -F '|' '$13=="Link" { print $17 "|" $2 "-" $3 "." $4 }' "$FL" | sort | uniq \
| awk -F '|' '{ print $1 }' | uniq -c | sort -nr | head -5 | column -t | pretty_indent

echo "☛ Symlinking font files is a way for non-font \
packages to comply with guidelines and avoid duplicating files, but it is \
also a symptom of missing or incomplete fontconfig support in the package. \
Please ask upstream to use fontconfig (possibly, via a higher-level library \
such as pangocairo)." | pretty_indent
fi

echo "– broken symlinks to font files:"

awk -F '|' '($13 == "Link") && ($17 == "")' "$FL" > tmp/tmp.csv
awk -F '|' '{ print $9 " → " $16 "|" $2 "-" $3 "." $4  }' tmp/tmp.csv \
  | column -t -s "|" | pretty_indent

summary tmp/tmp.csv

echo "– packages with fonts rpmlint errors on:"

awk -F '|' '($13 != "Link") && ($7 != "0")' "$FL" > tmp/tmp.csv

list-rpm tmp/tmp.csv

summary tmp/tmp.csv


# Magic and other parsing checks

echo "– packages with font files not identified as such by libmagic:"

awk -F '|' '($13 !~ /font/) && ($13 !~ /Font/) && ($13 != "Link")' "$FL" > tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
awk -F '|' '{ print $2 "-" $3 "." $4 }' tmp/tmp.csv | uniq \
  | while read rpm ; do
    awk -F '|' -v rpm="$rpm" '($2 "-" $3 "." $4) == rpm \
        { sum+=1 ; srpm =$1 } END \
        { print sum "|" rpm "|(" srpm ")|" }' tmp/tmp.csv
  done | sort -nr | column -t -s '|' | pretty_indent

summary tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
echo "☛ Either libmagic has a bug or the files are malformed and need to be \
fixed or dumped." | pretty_indent

echo "– packages with font files fc-query can not parse:"

awk -F '|' '($13 != "Link") && ($12 == "")' "$FL" > tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
awk -F '|' '{ print $2 "-" $3 "." $4 }' tmp/tmp.csv | uniq \
  | while read rpm ; do
    awk -F '|' -v rpm="$rpm" '($2 "-" $3 "." $4) == rpm \
        { sum+=1 ; srpm =$1 } END \
        { print sum "|" rpm "|(" srpm ")|" }' tmp/tmp.csv
  done | sort -nr | column -t -s '|' | pretty_indent

summary tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
echo "☛ Either fontconfig has a bug or the files are malformed and need to be \
fixed or dumped." | pretty_indent

echo "– packages with localized metadata but no English variant:"

awk -F '|' '($12 != "") && (($10 == "") || ($11 == ""))' "$FL" > tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
awk -F '|' '{ print $9 "|" $2 "-" $3 "." $4 }' tmp/tmp.csv \
  | column -t -s '|' | pretty_indent

summary tmp/tmp.csv

[ $(cat tmp/tmp.csv | wc -l) -gt 0 ] && \
echo "☛ The font files need to be fixed to declare metadata in English too." \
| pretty_indent

}

# End of function declarations

[ "$#" -lt "2" ] && usage

ID=$1
REPOID="$1-fontrepo"
REPOURL=$2
TIMESTAMP=$(date -u +%Y%m%dT%H%M%S)
ORIGDIR="$PWD"

FPL="font-packages.csv"
PWFL="packages-with-fonts.csv"
FFL="font-files.csv"
CSL="checksums.csv"
FL="repo-font-audit.csv"
FLNM="repo-font-audit-no-multilib.csv"
RES="repo-font-audit-$ID-$TIMESTAMP"
FLRES="repo-font-audit-$ID-$TIMESTAMP.csv"

TMPDIR=$(mktemp -d --tmpdir=/var/tmp $RES-XXXXXXXXXX)
cd $TMPDIR

mkdir tmp

collect
consolidate
analyse | tee report.txt

mkdir "$RES"
cp "$FL" tmp/rpmlint-*.txt report.txt "$RES"
tar cf "$RES.tar" "$RES"
xz -9 "$RES.tar"
mv "$FL" "$FLRES"
xz -9 "$FLRES"
mv "$RES.tar.xz" "$ORIGDIR/"
mv "$FLRES.xz" "$ORIGDIR/"
echo "1. Complete extracted data: $ORIGDIR/$RES.tar.xz"
echo "2. CSV summary: $ORIGDIR/$FLRES.xz"
cd "$ORIGDIR"
rm -fr "$TMPDIR"
echo "♻"
echo "Generated using repo-font-audit from http://fedoraproject.org/wiki/Fontpackages"
